/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro

Bases of topologies. Countability axioms.
-/
import topology.continuous_on

open set filter classical
open_locale topological_space filter
noncomputable theory

namespace topological_space
/- countability axioms

For our applications we are interested that there exists a countable basis, but we do not need the
concrete basis itself. This allows us to declare these type classes as `Prop` to use them as mixins.
-/
universe u
variables {Œ± : Type u} [t : topological_space Œ±]
include t

/-- A topological basis is one that satisfies the necessary conditions so that
  it suffices to take unions of the basis sets to get a topology (without taking
  finite intersections as well). -/
def is_topological_basis (s : set (set Œ±)) : Prop :=
(‚àÄt‚ÇÅ‚ààs, ‚àÄt‚ÇÇ‚ààs, ‚àÄ x ‚àà t‚ÇÅ ‚à© t‚ÇÇ, ‚àÉ t‚ÇÉ‚ààs, x ‚àà t‚ÇÉ ‚àß t‚ÇÉ ‚äÜ t‚ÇÅ ‚à© t‚ÇÇ) ‚àß
(‚ãÉ‚ÇÄ s) = univ ‚àß
t = generate_from s

lemma is_topological_basis_of_subbasis {s : set (set Œ±)} (hs : t = generate_from s) :
  is_topological_basis ((Œªf, ‚ãÇ‚ÇÄ f) '' {f:set (set Œ±) | finite f ‚àß f ‚äÜ s ‚àß (‚ãÇ‚ÇÄ f).nonempty}) :=
let b' := (Œªf, ‚ãÇ‚ÇÄ f) '' {f:set (set Œ±) | finite f ‚àß f ‚äÜ s ‚àß (‚ãÇ‚ÇÄ f).nonempty} in
‚ü®assume s‚ÇÅ ‚ü®t‚ÇÅ, ‚ü®hft‚ÇÅ, ht‚ÇÅb, ht‚ÇÅ‚ü©, eq‚ÇÅ‚ü© s‚ÇÇ ‚ü®t‚ÇÇ, ‚ü®hft‚ÇÇ, ht‚ÇÇb, ht‚ÇÇ‚ü©, eq‚ÇÇ‚ü©,
    have ie : ‚ãÇ‚ÇÄ(t‚ÇÅ ‚à™ t‚ÇÇ) = ‚ãÇ‚ÇÄ t‚ÇÅ ‚à© ‚ãÇ‚ÇÄ t‚ÇÇ, from Inf_union,
    eq‚ÇÅ ‚ñ∏ eq‚ÇÇ ‚ñ∏ assume x h,
      ‚ü®_, ‚ü®t‚ÇÅ ‚à™ t‚ÇÇ, ‚ü®hft‚ÇÅ.union hft‚ÇÇ, union_subset ht‚ÇÅb ht‚ÇÇb,
        ie.symm ‚ñ∏ ‚ü®_, h‚ü©‚ü©, ie‚ü©, h, subset.refl _‚ü©,
  eq_univ_iff_forall.2 $ assume a, ‚ü®univ, ‚ü®‚àÖ, ‚ü®finite_empty, empty_subset _,
    by rw sInter_empty; exact ‚ü®a, mem_univ a‚ü©‚ü©, sInter_empty‚ü©, mem_univ _‚ü©,
 have generate_from s = generate_from b',
    from le_antisymm
      (le_generate_from $ assume u ‚ü®t, ‚ü®hft, htb, ne‚ü©, eq‚ü©,
        eq ‚ñ∏ @is_open_sInter _ (generate_from s) _ hft (assume s hs, generate_open.basic _ $ htb hs))
      (le_generate_from $ assume s hs,
        s.eq_empty_or_nonempty.elim
          (assume : s = ‚àÖ, by rw [this]; apply @is_open_empty _ _)
          (assume : s.nonempty, generate_open.basic _ ‚ü®{s}, ‚ü®finite_singleton s, singleton_subset_iff.2 hs,
            by rwa sInter_singleton‚ü©, sInter_singleton s‚ü©)),
  this ‚ñ∏ hs‚ü©

lemma is_topological_basis_of_open_of_nhds {s : set (set Œ±)}
  (h_open : ‚àÄ u ‚àà s, is_open u)
  (h_nhds : ‚àÄ(a:Œ±) (u : set Œ±), a ‚àà u ‚Üí is_open u ‚Üí ‚àÉv ‚àà s, a ‚àà v ‚àß v ‚äÜ u) :
  is_topological_basis s :=
‚ü®assume t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ x ‚ü®xt‚ÇÅ, xt‚ÇÇ‚ü©,
    h_nhds x (t‚ÇÅ ‚à© t‚ÇÇ) ‚ü®xt‚ÇÅ, xt‚ÇÇ‚ü©
      (is_open_inter (h_open _ ht‚ÇÅ) (h_open _ ht‚ÇÇ)),
  eq_univ_iff_forall.2 $ assume a,
    let ‚ü®u, h‚ÇÅ, h‚ÇÇ, _‚ü© := h_nhds a univ trivial is_open_univ in
    ‚ü®u, h‚ÇÅ, h‚ÇÇ‚ü©,
  le_antisymm
    (le_generate_from h_open)
    (assume u hu,
      (@is_open_iff_nhds Œ± (generate_from _) _).mpr $ assume a hau,
        let ‚ü®v, hvs, hav, hvu‚ü© := h_nhds a u hau hu in
        by rw nhds_generate_from; exact infi_le_of_le v (infi_le_of_le ‚ü®hav, hvs‚ü© $ le_principal_iff.2 hvu))‚ü©

lemma mem_nhds_of_is_topological_basis {a : Œ±} {s : set Œ±} {b : set (set Œ±)}
  (hb : is_topological_basis b) : s ‚àà ùìù a ‚Üî ‚àÉt‚ààb, a ‚àà t ‚àß t ‚äÜ s :=
begin
  change s ‚àà (ùìù a).sets ‚Üî ‚àÉt‚ààb, a ‚àà t ‚àß t ‚äÜ s,
  rw [hb.2.2, nhds_generate_from, binfi_sets_eq],
  { simp only [mem_bUnion_iff, exists_prop, mem_set_of_eq, and_assoc, and.left_comm], refl },
  { exact assume s ‚ü®hs‚ÇÅ, hs‚ÇÇ‚ü© t ‚ü®ht‚ÇÅ, ht‚ÇÇ‚ü©,
      have a ‚àà s ‚à© t, from ‚ü®hs‚ÇÅ, ht‚ÇÅ‚ü©,
      let ‚ü®u, hu‚ÇÅ, hu‚ÇÇ, hu‚ÇÉ‚ü© := hb.1 _ hs‚ÇÇ _ ht‚ÇÇ _ this in
      ‚ü®u, ‚ü®hu‚ÇÇ, hu‚ÇÅ‚ü©, le_principal_iff.2 (subset.trans hu‚ÇÉ (inter_subset_left _ _)),
        le_principal_iff.2 (subset.trans hu‚ÇÉ (inter_subset_right _ _))‚ü© },
  { rcases eq_univ_iff_forall.1 hb.2.1 a with ‚ü®i, h1, h2‚ü©,
    exact ‚ü®i, h2, h1‚ü© }
end

lemma is_open_of_is_topological_basis {s : set Œ±} {b : set (set Œ±)}
  (hb : is_topological_basis b) (hs : s ‚àà b) : is_open s :=
is_open_iff_mem_nhds.2 $ Œª a as,
(mem_nhds_of_is_topological_basis hb).2 ‚ü®s, hs, as, subset.refl _‚ü©

lemma mem_basis_subset_of_mem_open {b : set (set Œ±)}
  (hb : is_topological_basis b) {a:Œ±} {u : set Œ±} (au : a ‚àà u)
  (ou : is_open u) : ‚àÉv ‚àà b, a ‚àà v ‚àß v ‚äÜ u :=
(mem_nhds_of_is_topological_basis hb).1 $ mem_nhds_sets ou au

lemma sUnion_basis_of_is_open {B : set (set Œ±)}
  (hB : is_topological_basis B) {u : set Œ±} (ou : is_open u) :
  ‚àÉ S ‚äÜ B, u = ‚ãÉ‚ÇÄ S :=
‚ü®{s ‚àà B | s ‚äÜ u}, Œª s h, h.1, set.ext $ Œª a,
  ‚ü®Œª ha, let ‚ü®b, hb, ab, bu‚ü© := mem_basis_subset_of_mem_open hB ha ou in
         ‚ü®b, ‚ü®hb, bu‚ü©, ab‚ü©,
   Œª ‚ü®b, ‚ü®hb, bu‚ü©, ab‚ü©, bu ab‚ü©‚ü©

lemma Union_basis_of_is_open {B : set (set Œ±)}
  (hB : is_topological_basis B) {u : set Œ±} (ou : is_open u) :
  ‚àÉ (Œ≤ : Type u) (f : Œ≤ ‚Üí set Œ±), u = (‚ãÉ i, f i) ‚àß ‚àÄ i, f i ‚àà B :=
let ‚ü®S, sb, su‚ü© := sUnion_basis_of_is_open hB ou in
‚ü®S, subtype.val, su.trans set.sUnion_eq_Union, Œª ‚ü®b, h‚ü©, sb h‚ü©

variables (Œ±)

/-- A separable space is one with a countable dense subset, available through
`topological_space.exists_countable_dense`. If `Œ±` is also known to be nonempty, then
`topological_space.dense_seq` provides a sequence `‚Ñï ‚Üí Œ±` with dense range, see
`topological_space.dense_range_dense_seq`.

If `Œ±` is a uniform space with countably generated uniformity filter (e.g., an `emetric_space`),
then this condition is equivalent to `topological_space.second_countable_topology Œ±`. In this case
the latter should be used as a typeclass argument in theorems because Lean can automatically deduce
`separable_space` from `second_countable_topology` but it can't deduce `second_countable_topology`
and `emetric_space`. -/
class separable_space : Prop :=
(exists_countable_dense : ‚àÉs:set Œ±, countable s ‚àß dense s)

lemma exists_countable_dense [separable_space Œ±] :
  ‚àÉ s : set Œ±, countable s ‚àß dense s :=
separable_space.exists_countable_dense

/-- A nonempty separable space admits a sequence with dense range. Instead of running `cases` on the
conclusion of this lemma, you might want to use `topological_space.dense_seq` and
`topological_space.dense_range_dense_seq`.

If `Œ±` might be empty, then `exists_countable_dense` is the main way to use separability of `Œ±`. -/
lemma exists_dense_seq [separable_space Œ±] [nonempty Œ±] : ‚àÉ u : ‚Ñï ‚Üí Œ±, dense_range u :=
begin
  obtain ‚ü®s : set Œ±, hs, s_dense‚ü© := exists_countable_dense Œ±,
  cases countable_iff_exists_surjective.mp hs with u hu,
  exact ‚ü®u, s_dense.mono hu‚ü©,
end

/-- A sequence dense in a non-empty separable topological space.

If `Œ±` might be empty, then `exists_countable_dense` is the main way to use separability of `Œ±`. -/
def dense_seq [separable_space Œ±] [nonempty Œ±] : ‚Ñï ‚Üí Œ± := classical.some (exists_dense_seq Œ±)

/-- The sequence `dense_seq Œ±` has dense range. -/
@[simp] lemma dense_range_dense_seq [separable_space Œ±] [nonempty Œ±] :
  dense_range (dense_seq Œ±) := classical.some_spec (exists_dense_seq Œ±)

end topological_space

open topological_space

/-- If `Œ±` is a separable space and `f : Œ± ‚Üí Œ≤` is a continuous map with dense range, then `Œ≤` is
a separable space as well. E.g., the completion of a separable uniform space is separable. -/
protected lemma dense_range.separable_space {Œ± Œ≤ : Type*} [topological_space Œ±] [separable_space Œ±]
  [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (h : dense_range f) (h' : continuous f) :
  separable_space Œ≤ :=
let ‚ü®s, s_cnt, s_dense‚ü© := exists_countable_dense Œ± in
‚ü®‚ü®f '' s, countable.image s_cnt f, h.dense_image h' s_dense‚ü©‚ü©

namespace topological_space
universe u
variables (Œ± : Type u) [t : topological_space Œ±]
include t


/-- A first-countable space is one in which every point has a
  countable neighborhood basis. -/
class first_countable_topology : Prop :=
(nhds_generated_countable : ‚àÄa:Œ±, (ùìù a).is_countably_generated)

namespace first_countable_topology
variable {Œ±}

lemma tendsto_subseq [first_countable_topology Œ±] {u : ‚Ñï ‚Üí Œ±} {x : Œ±} (hx : map_cluster_pt x at_top u) :
  ‚àÉ (œà : ‚Ñï ‚Üí ‚Ñï), (strict_mono œà) ‚àß (tendsto (u ‚àò œà) at_top (ùìù x)) :=
(nhds_generated_countable x).subseq_tendsto hx

end first_countable_topology

variables {Œ±}

lemma is_countably_generated_nhds [first_countable_topology Œ±] (x : Œ±) :
  is_countably_generated (ùìù x) :=
first_countable_topology.nhds_generated_countable x

lemma is_countably_generated_nhds_within [first_countable_topology Œ±] (x : Œ±) (s : set Œ±) :
  is_countably_generated (ùìù[s] x) :=
(is_countably_generated_nhds x).inf_principal s

variable (Œ±)

/-- A second-countable space is one with a countable basis. -/
class second_countable_topology : Prop :=
(is_open_generated_countable [] : ‚àÉb:set (set Œ±), countable b ‚àß t = topological_space.generate_from b)

@[priority 100] -- see Note [lower instance priority]
instance second_countable_topology.to_first_countable_topology
  [second_countable_topology Œ±] : first_countable_topology Œ± :=
let ‚ü®b, hb, eq‚ü© := second_countable_topology.is_open_generated_countable Œ± in
‚ü®begin
   intros,
   rw [eq, nhds_generate_from],
   exact is_countably_generated_binfi_principal (hb.mono (assume x, and.right)),
 end‚ü©

lemma second_countable_topology_induced (Œ≤)
  [t : topological_space Œ≤] [second_countable_topology Œ≤] (f : Œ± ‚Üí Œ≤) :
  @second_countable_topology Œ± (t.induced f) :=
begin
  rcases second_countable_topology.is_open_generated_countable Œ≤ with ‚ü®b, hb, eq‚ü©,
  refine { is_open_generated_countable := ‚ü®preimage f '' b, hb.image _, _‚ü© },
  rw [eq, induced_generate_from_eq]
end

instance subtype.second_countable_topology
  (s : set Œ±) [second_countable_topology Œ±] : second_countable_topology s :=
second_countable_topology_induced s Œ± coe

lemma is_open_generated_countable_inter [second_countable_topology Œ±] :
  ‚àÉb:set (set Œ±), countable b ‚àß ‚àÖ ‚àâ b ‚àß is_topological_basis b :=
let ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := second_countable_topology.is_open_generated_countable Œ± in
let b' := (Œªs, ‚ãÇ‚ÇÄ s) '' {s:set (set Œ±) | finite s ‚àß s ‚äÜ b ‚àß (‚ãÇ‚ÇÄ s).nonempty} in
‚ü®b',
  ((countable_set_of_finite_subset hb‚ÇÅ).mono
    (by { simp only [‚Üê and_assoc], apply inter_subset_left })).image _,
  assume ‚ü®s, ‚ü®_, _, hn‚ü©, hp‚ü©, absurd hn (not_nonempty_iff_eq_empty.2 hp),
  is_topological_basis_of_subbasis hb‚ÇÇ‚ü©

/- TODO: more fine grained instances for first_countable_topology, separable_space, t2_space, ... -/
instance {Œ≤ : Type*} [topological_space Œ≤]
  [second_countable_topology Œ±] [second_countable_topology Œ≤] : second_countable_topology (Œ± √ó Œ≤) :=
‚ü®let ‚ü®a, ha‚ÇÅ, ha‚ÇÇ, ha‚ÇÉ, ha‚ÇÑ, ha‚ÇÖ‚ü© := is_open_generated_countable_inter Œ± in
  let ‚ü®b, hb‚ÇÅ, hb‚ÇÇ, hb‚ÇÉ, hb‚ÇÑ, hb‚ÇÖ‚ü© := is_open_generated_countable_inter Œ≤ in
  ‚ü®{g | ‚àÉu‚ààa, ‚àÉv‚ààb, g = set.prod u v},
    have {g | ‚àÉu‚ààa, ‚àÉv‚ààb, g = set.prod u v} = (‚ãÉu‚ààa, ‚ãÉv‚ààb, {set.prod u v}),
      by apply set.ext; simp,
    by rw [this]; exact (ha‚ÇÅ.bUnion $ assume u hu, hb‚ÇÅ.bUnion $ by simp),
    by rw [ha‚ÇÖ, hb‚ÇÖ, prod_generate_from_generate_from_eq ha‚ÇÑ hb‚ÇÑ]‚ü©‚ü©

instance second_countable_topology_fintype {Œπ : Type*} {œÄ : Œπ ‚Üí Type*}
  [fintype Œπ] [t : ‚àÄa, topological_space (œÄ a)] [sc : ‚àÄa, second_countable_topology (œÄ a)] :
  second_countable_topology (‚àÄa, œÄ a) :=
have ‚àÄi, ‚àÉb : set (set (œÄ i)), countable b ‚àß ‚àÖ ‚àâ b ‚àß is_topological_basis b, from
  assume a, @is_open_generated_countable_inter (œÄ a) _ (sc a),
let ‚ü®g, hg‚ü© := classical.axiom_of_choice this in
have t = (Œªa, generate_from (g a)), from funext $ assume a, (hg a).2.2.2.2,
begin
  constructor,
  refine ‚ü®pi univ '' pi univ g, countable.image _ _, _‚ü©,
  { suffices : countable {f : Œ†a, set (œÄ a) | ‚àÄa, f a ‚àà g a}, { simpa [pi] },
    exact countable_pi (assume i, (hg i).1), },
  rw [this, pi_generate_from_eq_fintype],
  { congr' 1 with f, simp [pi, eq_comm] },
  exact assume a, (hg a).2.2.2.1
end

@[priority 100] -- see Note [lower instance priority]
instance second_countable_topology.to_separable_space
  [second_countable_topology Œ±] : separable_space Œ± :=
begin
  rcases is_open_generated_countable_inter Œ± with  ‚ü®b, hbc, hbne, hb, hbU, eq‚ü©,
  set S : Œ± ‚Üí set (set Œ±) := Œª a, {s : set Œ± | a ‚àà s ‚àß s ‚àà b},
  have nhds_eq : ‚àÄa, ùìù a = (‚®Ö s ‚àà S a, ùìü s),
  { intro a, rw [eq, nhds_generate_from] },
  have : ‚àÄ s ‚àà b, set.nonempty s :=
    assume s hs, ne_empty_iff_nonempty.1 $ Œª eq, absurd hs (eq.symm ‚ñ∏ hbne),
  choose f hf,
  refine ‚ü®‚ü®‚ãÉ s ‚àà b, {f s ‚Äπ_‚Ä∫}, hbc.bUnion (Œª _ _, countable_singleton _), Œª a, _‚ü©‚ü©,
  suffices : (‚®Ö s ‚àà S a, ùìü (s ‚à© ‚ãÉ t ‚àà b, {f t ‚Äπ_‚Ä∫})).ne_bot,
  { obtain ‚ü®t, htb, hta‚ü© : a ‚àà ‚ãÉ‚ÇÄ b, { simp only [hbU] },
    have A : ‚àÉ s, s ‚àà S a := ‚ü®t, hta, htb‚ü©,
    simpa only [‚Üê inf_principal, mem_closure_iff_cluster_pt,
      cluster_pt, nhds_eq, binfi_inf A] using this },
  rw [infi_subtype'],
  haveI : nonempty Œ± := ‚ü®a‚ü©,
  refine infi_ne_bot_of_directed _ _,
  { rintros ‚ü®s‚ÇÅ, has‚ÇÅ, hs‚ÇÅ‚ü© ‚ü®s‚ÇÇ, has‚ÇÇ, hs‚ÇÇ‚ü©,
    obtain ‚ü®t, htb, hta, ht‚ü© : ‚àÉ t ‚àà b, a ‚àà t ‚àß t ‚äÜ s‚ÇÅ ‚à© s‚ÇÇ,
      from hb _ hs‚ÇÅ _ hs‚ÇÇ a ‚ü®has‚ÇÅ, has‚ÇÇ‚ü©,
    refine ‚ü®‚ü®t, hta, htb‚ü©, _‚ü©,
    simp only [subset_inter_iff] at ht,
    simp only [principal_mono, subtype.coe_mk, (‚â•)],
    exact ‚ü®inter_subset_inter_left _ ht.1, inter_subset_inter_left _ ht.2‚ü© },
  rintros ‚ü®s, hsa, hsb‚ü©,
  suffices : (s ‚à© ‚ãÉ t ‚àà b, {f t ‚Äπ_‚Ä∫}).nonempty, { simpa [principal_ne_bot_iff] },
  refine ‚ü®_, hf _ hsb, _‚ü©,
  simp only [mem_Union],
  exact ‚ü®s, hsb, rfl‚ü©
end

variables {Œ±}

lemma is_open_Union_countable [second_countable_topology Œ±]
  {Œπ} (s : Œπ ‚Üí set Œ±) (H : ‚àÄ i, is_open (s i)) :
  ‚àÉ T : set Œπ, countable T ‚àß (‚ãÉ i ‚àà T, s i) = ‚ãÉ i, s i :=
let ‚ü®B, cB, _, bB‚ü© := is_open_generated_countable_inter Œ± in
begin
  let B' := {b ‚àà B | ‚àÉ i, b ‚äÜ s i},
  choose f hf using Œª b:B', b.2.2,
  haveI : encodable B' := (cB.mono (sep_subset _ _)).to_encodable,
  refine ‚ü®_, countable_range f,
    subset.antisymm (bUnion_subset_Union _ _) (sUnion_subset _)‚ü©,
  rintro _ ‚ü®i, rfl‚ü© x xs,
  rcases mem_basis_subset_of_mem_open bB xs (H _) with ‚ü®b, hb, xb, bs‚ü©,
  exact ‚ü®_, ‚ü®_, rfl‚ü©, _, ‚ü®‚ü®‚ü®_, hb, _, bs‚ü©, rfl‚ü©, rfl‚ü©, hf _ (by exact xb)‚ü©
end

lemma is_open_sUnion_countable [second_countable_topology Œ±]
  (S : set (set Œ±)) (H : ‚àÄ s ‚àà S, is_open s) :
  ‚àÉ T : set (set Œ±), countable T ‚àß T ‚äÜ S ‚àß ‚ãÉ‚ÇÄ T = ‚ãÉ‚ÇÄ S :=
let ‚ü®T, cT, hT‚ü© := is_open_Union_countable (Œª s:S, s.1) (Œª s, H s.1 s.2) in
‚ü®subtype.val '' T, cT.image _,
  image_subset_iff.2 $ Œª ‚ü®x, xs‚ü© xt, xs,
  by rwa [sUnion_image, sUnion_eq_Union]‚ü©

end topological_space
