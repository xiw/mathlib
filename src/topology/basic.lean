/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Jeremy Avigad
-/
import order.filter.ultrafilter
import order.filter.partial

noncomputable theory

/-!
# Basic theory of topological spaces.

The main definition is the type class `topological space Œ±` which endows a type `Œ±` with a topology.
Then `set Œ±` gets predicates `is_open`, `is_closed` and functions `interior`, `closure` and
`frontier`. Each point `x` of `Œ±` gets a neighborhood filter `ùìù x`. A filter `F` on `Œ±`¬†has
`x` as a cluster point if `is_cluster_pt x F : ùìù x ‚äì F ‚â† ‚ä•`. A map `f : Œπ ‚Üí Œ±` clusters at `x`
along `F : filter Œπ` if `map_cluster_pt x F f : cluster_pt x (map f F)`. In particular
the notion of cluster point of a sequence `u` is `map_cluster_pt x at_top u`.

This file also defines locally finite families of subsets of `Œ±`.

For topological spaces `Œ±` and `Œ≤`, a function `f : Œ± ‚Üí Œ≤` and a point `a : Œ±`,
`continuous_at f a` means `f` is continuous at `a`, and global continuity is
`continuous f`. There is also a version of continuity `pcontinuous` for
partially defined functions.

## Notation

* `ùìù x`: the filter of neighborhoods of a point `x`;
* `ùìü s`: the principal filter of a set `s`;

## Implementation notes

Topology in mathlib heavily uses filters (even more than in Bourbaki). See explanations in
<https://leanprover-community.github.io/theories/topology.html>.

## References

*  [N. Bourbaki, *General Topology*][bourbaki1966]
*  [I. M. James, *Topologies and Uniformities*][james1999]

## Tags

topological space, interior, closure, frontier, neighborhood, continuity, continuous function
-/

open set filter classical
open_locale classical filter

universes u v w

/-!
###¬†Topological spaces
-/

/-- A topology on `Œ±`. -/
@[protect_proj] structure topological_space (Œ± : Type u) :=
(is_open        : set Œ± ‚Üí Prop)
(is_open_univ   : is_open univ)
(is_open_inter  : ‚àÄs t, is_open s ‚Üí is_open t ‚Üí is_open (s ‚à© t))
(is_open_sUnion : ‚àÄs, (‚àÄt‚ààs, is_open t) ‚Üí is_open (‚ãÉ‚ÇÄ s))

attribute [class] topological_space

/-- A constructor for topologies by specifying the closed sets,
and showing that they satisfy the appropriate conditions. -/
def topological_space.of_closed {Œ± : Type u} (T : set (set Œ±))
  (empty_mem : ‚àÖ ‚àà T) (sInter_mem : ‚àÄ A ‚äÜ T, ‚ãÇ‚ÇÄ A ‚àà T) (union_mem : ‚àÄ A B ‚àà T, A ‚à™ B ‚àà T) :
  topological_space Œ± :=
{ is_open := Œª X, X·∂ú ‚àà T,
  is_open_univ := by simp [empty_mem],
  is_open_inter := Œª s t hs ht, by simpa [set.compl_inter] using union_mem s·∂ú t·∂ú hs ht,
  is_open_sUnion := Œª s hs,
    by rw set.compl_sUnion; exact sInter_mem (set.compl '' s)
    (Œª z ‚ü®y, hy, hz‚ü©, by simpa [hz.symm] using hs y hy) }

section topological_space

variables {Œ± : Type u} {Œ≤ : Type v} {Œπ : Sort w} {a : Œ±} {s s‚ÇÅ s‚ÇÇ : set Œ±} {p p‚ÇÅ p‚ÇÇ : Œ± ‚Üí Prop}

@[ext]
lemma topological_space_eq : ‚àÄ {f g : topological_space Œ±}, f.is_open = g.is_open ‚Üí f = g
| ‚ü®a, _, _, _‚ü© ‚ü®b, _, _, _‚ü© rfl := rfl

section
variables [t : topological_space Œ±]
include t

/-- `is_open s` means that `s` is open in the ambient topological space on `Œ±` -/
def is_open (s : set Œ±) : Prop := topological_space.is_open t s

@[simp]
lemma is_open_univ : is_open (univ : set Œ±) := topological_space.is_open_univ t

lemma is_open_inter (h‚ÇÅ : is_open s‚ÇÅ) (h‚ÇÇ : is_open s‚ÇÇ) : is_open (s‚ÇÅ ‚à© s‚ÇÇ) :=
topological_space.is_open_inter t s‚ÇÅ s‚ÇÇ h‚ÇÅ h‚ÇÇ

lemma is_open_sUnion {s : set (set Œ±)} (h : ‚àÄt ‚àà s, is_open t) : is_open (‚ãÉ‚ÇÄ s) :=
topological_space.is_open_sUnion t s h

end

lemma is_open_fold {s : set Œ±} {t : topological_space Œ±} : t.is_open s = @is_open Œ± t s :=
rfl

variables [topological_space Œ±]

lemma is_open_Union {f : Œπ ‚Üí set Œ±} (h : ‚àÄi, is_open (f i)) : is_open (‚ãÉi, f i) :=
is_open_sUnion $ by rintro _ ‚ü®i, rfl‚ü©; exact h i

lemma is_open_bUnion {s : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (h : ‚àÄi‚ààs, is_open (f i)) :
  is_open (‚ãÉi‚ààs, f i) :=
is_open_Union $ assume i, is_open_Union $ assume hi, h i hi

lemma is_open_union (h‚ÇÅ : is_open s‚ÇÅ) (h‚ÇÇ : is_open s‚ÇÇ) : is_open (s‚ÇÅ ‚à™ s‚ÇÇ) :=
by rw union_eq_Union; exact is_open_Union (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©)

@[simp] lemma is_open_empty : is_open (‚àÖ : set Œ±) :=
by rw ‚Üê sUnion_empty; exact is_open_sUnion (assume a, false.elim)

lemma is_open_sInter {s : set (set Œ±)} (hs : finite s) : (‚àÄt ‚àà s, is_open t) ‚Üí is_open (‚ãÇ‚ÇÄ s) :=
finite.induction_on hs (Œª _, by rw sInter_empty; exact is_open_univ) $
Œª a s has hs ih h, by rw sInter_insert; exact
is_open_inter (h _ $ mem_insert _ _) (ih $ Œª t, h t ‚àò mem_insert_of_mem _)

lemma is_open_bInter {s : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (hs : finite s) :
  (‚àÄi‚ààs, is_open (f i)) ‚Üí is_open (‚ãÇi‚ààs, f i) :=
finite.induction_on hs
  (Œª _, by rw bInter_empty; exact is_open_univ)
  (Œª a s has hs ih h, by rw bInter_insert; exact
    is_open_inter (h a (mem_insert _ _)) (ih (Œª i hi, h i (mem_insert_of_mem _ hi))))

lemma is_open_Inter [fintype Œ≤] {s : Œ≤ ‚Üí set Œ±}
  (h : ‚àÄ i, is_open (s i)) : is_open (‚ãÇ i, s i) :=
suffices is_open (‚ãÇ (i : Œ≤) (hi : i ‚àà @univ Œ≤), s i), by simpa,
is_open_bInter finite_univ (Œª i _, h i)

lemma is_open_Inter_prop {p : Prop} {s : p ‚Üí set Œ±}
  (h : ‚àÄ h : p, is_open (s h)) : is_open (Inter s) :=
by by_cases p; simp *

lemma is_open_const {p : Prop} : is_open {a : Œ± | p} :=
by_cases
  (assume : p, begin simp only [this]; exact is_open_univ end)
  (assume : ¬¨ p, begin simp only [this]; exact is_open_empty end)

lemma is_open_and : is_open {a | p‚ÇÅ a} ‚Üí is_open {a | p‚ÇÇ a} ‚Üí is_open {a | p‚ÇÅ a ‚àß p‚ÇÇ a} :=
is_open_inter

/-- A set is closed if its complement is open -/
def is_closed (s : set Œ±) : Prop := is_open s·∂ú

@[simp] lemma is_closed_empty : is_closed (‚àÖ : set Œ±) :=
by unfold is_closed; rw compl_empty; exact is_open_univ

@[simp] lemma is_closed_univ : is_closed (univ : set Œ±) :=
by unfold is_closed; rw compl_univ; exact is_open_empty

lemma is_closed_union : is_closed s‚ÇÅ ‚Üí is_closed s‚ÇÇ ‚Üí is_closed (s‚ÇÅ ‚à™ s‚ÇÇ) :=
Œª h‚ÇÅ h‚ÇÇ, by unfold is_closed; rw compl_union; exact is_open_inter h‚ÇÅ h‚ÇÇ

lemma is_closed_sInter {s : set (set Œ±)} : (‚àÄt ‚àà s, is_closed t) ‚Üí is_closed (‚ãÇ‚ÇÄ s) :=
by simp only [is_closed, compl_sInter, sUnion_image]; exact assume h, is_open_Union $ assume t, is_open_Union $ assume ht, h t ht

lemma is_closed_Inter {f : Œπ ‚Üí set Œ±} (h : ‚àÄi, is_closed (f i)) : is_closed (‚ãÇi, f i ) :=
is_closed_sInter $ assume t ‚ü®i, (heq : f i = t)‚ü©, heq ‚ñ∏ h i

@[simp] lemma is_open_compl_iff {s : set Œ±} : is_open s·∂ú ‚Üî is_closed s := iff.rfl

@[simp] lemma is_closed_compl_iff {s : set Œ±} : is_closed s·∂ú ‚Üî is_open s :=
by rw [‚Üêis_open_compl_iff, compl_compl]

lemma is_open_diff {s t : set Œ±} (h‚ÇÅ : is_open s) (h‚ÇÇ : is_closed t) : is_open (s \ t) :=
is_open_inter h‚ÇÅ $ is_open_compl_iff.mpr h‚ÇÇ

lemma is_closed_inter (h‚ÇÅ : is_closed s‚ÇÅ) (h‚ÇÇ : is_closed s‚ÇÇ) : is_closed (s‚ÇÅ ‚à© s‚ÇÇ) :=
by rw [is_closed, compl_inter]; exact is_open_union h‚ÇÅ h‚ÇÇ

lemma is_closed_bUnion {s : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (hs : finite s) :
  (‚àÄi‚ààs, is_closed (f i)) ‚Üí is_closed (‚ãÉi‚ààs, f i) :=
finite.induction_on hs
  (Œª _, by rw bUnion_empty; exact is_closed_empty)
  (Œª a s has hs ih h, by rw bUnion_insert; exact
    is_closed_union (h a (mem_insert _ _)) (ih (Œª i hi, h i (mem_insert_of_mem _ hi))))

lemma is_closed_Union [fintype Œ≤] {s : Œ≤ ‚Üí set Œ±}
  (h : ‚àÄ i, is_closed (s i)) : is_closed (Union s) :=
suffices is_closed (‚ãÉ (i : Œ≤) (hi : i ‚àà @univ Œ≤), s i),
  by convert this; simp [set.ext_iff],
is_closed_bUnion finite_univ (Œª i _, h i)

lemma is_closed_Union_prop {p : Prop} {s : p ‚Üí set Œ±}
  (h : ‚àÄ h : p, is_closed (s h)) : is_closed (Union s) :=
by by_cases p; simp *

lemma is_closed_imp {p q : Œ± ‚Üí Prop} (hp : is_open {x | p x})
  (hq : is_closed {x | q x}) : is_closed {x | p x ‚Üí q x} :=
have {x | p x ‚Üí q x} = {x | p x}·∂ú ‚à™ {x | q x}, from set.ext $ Œª x, imp_iff_not_or,
by rw [this]; exact is_closed_union (is_closed_compl_iff.mpr hp) hq

lemma is_open_neg : is_closed {a | p a} ‚Üí is_open {a | ¬¨ p a} :=
is_open_compl_iff.mpr

/-!
### Interior of a set
-/

/-- The interior of a set `s` is the largest open subset of `s`. -/
def interior (s : set Œ±) : set Œ± := ‚ãÉ‚ÇÄ {t | is_open t ‚àß t ‚äÜ s}

lemma mem_interior {s : set Œ±} {x : Œ±} :
  x ‚àà interior s ‚Üî ‚àÉ t ‚äÜ s, is_open t ‚àß x ‚àà t :=
by simp only [interior, mem_set_of_eq, exists_prop, and_assoc, and.left_comm]

@[simp] lemma is_open_interior {s : set Œ±} : is_open (interior s) :=
is_open_sUnion $ assume t ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h‚ÇÅ

lemma interior_subset {s : set Œ±} : interior s ‚äÜ s :=
sUnion_subset $ assume t ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h‚ÇÇ

lemma interior_maximal {s t : set Œ±} (h‚ÇÅ : t ‚äÜ s) (h‚ÇÇ : is_open t) : t ‚äÜ interior s :=
subset_sUnion_of_mem ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©

lemma is_open.interior_eq {s : set Œ±} (h : is_open s) : interior s = s :=
subset.antisymm interior_subset (interior_maximal (subset.refl s) h)

lemma interior_eq_iff_open {s : set Œ±} : interior s = s ‚Üî is_open s :=
‚ü®assume h, h ‚ñ∏ is_open_interior, is_open.interior_eq‚ü©

lemma subset_interior_iff_open {s : set Œ±} : s ‚äÜ interior s ‚Üî is_open s :=
by simp only [interior_eq_iff_open.symm, subset.antisymm_iff, interior_subset, true_and]

lemma subset_interior_iff_subset_of_open {s t : set Œ±} (h‚ÇÅ : is_open s) :
  s ‚äÜ interior t ‚Üî s ‚äÜ t :=
‚ü®assume h, subset.trans h interior_subset, assume h‚ÇÇ, interior_maximal h‚ÇÇ h‚ÇÅ‚ü©

lemma interior_mono {s t : set Œ±} (h : s ‚äÜ t) : interior s ‚äÜ interior t :=
interior_maximal (subset.trans interior_subset h) is_open_interior

@[simp] lemma interior_empty : interior (‚àÖ : set Œ±) = ‚àÖ :=
is_open_empty.interior_eq

@[simp] lemma interior_univ : interior (univ : set Œ±) = univ :=
is_open_univ.interior_eq

@[simp] lemma interior_interior {s : set Œ±} : interior (interior s) = interior s :=
is_open_interior.interior_eq

@[simp] lemma interior_inter {s t : set Œ±} : interior (s ‚à© t) = interior s ‚à© interior t :=
subset.antisymm
  (subset_inter (interior_mono $ inter_subset_left s t) (interior_mono $ inter_subset_right s t))
  (interior_maximal (inter_subset_inter interior_subset interior_subset) $ is_open_inter is_open_interior is_open_interior)

lemma interior_union_is_closed_of_interior_empty {s t : set Œ±} (h‚ÇÅ : is_closed s) (h‚ÇÇ : interior t = ‚àÖ) :
  interior (s ‚à™ t) = interior s :=
have interior (s ‚à™ t) ‚äÜ s, from
  assume x ‚ü®u, ‚ü®(hu‚ÇÅ : is_open u), (hu‚ÇÇ : u ‚äÜ s ‚à™ t)‚ü©, (hx‚ÇÅ : x ‚àà u)‚ü©,
  classical.by_contradiction $ assume hx‚ÇÇ : x ‚àâ s,
    have u \ s ‚äÜ t,
      from assume x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, or.resolve_left (hu‚ÇÇ h‚ÇÅ) h‚ÇÇ,
    have u \ s ‚äÜ interior t,
      by rwa subset_interior_iff_subset_of_open (is_open_diff hu‚ÇÅ h‚ÇÅ),
    have u \ s ‚äÜ ‚àÖ,
      by rwa h‚ÇÇ at this,
    this ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©,
subset.antisymm
  (interior_maximal this is_open_interior)
  (interior_mono $ subset_union_left _ _)

lemma is_open_iff_forall_mem_open : is_open s ‚Üî ‚àÄ x ‚àà s, ‚àÉ t ‚äÜ s, is_open t ‚àß x ‚àà t :=
by rw ‚Üê subset_interior_iff_open; simp only [subset_def, mem_interior]

/-!
###¬†Closure of a set
-/

/-- The closure of `s` is the smallest closed set containing `s`. -/
def closure (s : set Œ±) : set Œ± := ‚ãÇ‚ÇÄ {t | is_closed t ‚àß s ‚äÜ t}

@[simp] lemma is_closed_closure {s : set Œ±} : is_closed (closure s) :=
is_closed_sInter $ assume t ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h‚ÇÅ

lemma subset_closure {s : set Œ±} : s ‚äÜ closure s :=
subset_sInter $ assume t ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h‚ÇÇ

lemma closure_minimal {s t : set Œ±} (h‚ÇÅ : s ‚äÜ t) (h‚ÇÇ : is_closed t) : closure s ‚äÜ t :=
sInter_subset_of_mem ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©

lemma is_closed.closure_eq {s : set Œ±} (h : is_closed s) : closure s = s :=
subset.antisymm (closure_minimal (subset.refl s) h) subset_closure

lemma is_closed.closure_subset {s : set Œ±} (hs : is_closed s) : closure s ‚äÜ s :=
closure_minimal (subset.refl _) hs

lemma is_closed.closure_subset_iff {s t : set Œ±} (h‚ÇÅ : is_closed t) :
  closure s ‚äÜ t ‚Üî s ‚äÜ t :=
‚ü®subset.trans subset_closure, assume h, closure_minimal h h‚ÇÅ‚ü©

lemma closure_mono {s t : set Œ±} (h : s ‚äÜ t) : closure s ‚äÜ closure t :=
closure_minimal (subset.trans h subset_closure) is_closed_closure

lemma monotone_closure (Œ± : Type*) [topological_space Œ±] : monotone (@closure Œ± _) :=
Œª _ _, closure_mono

lemma closure_inter_subset_inter_closure (s t : set Œ±) :
  closure (s ‚à© t) ‚äÜ closure s ‚à© closure t :=
(monotone_closure Œ±).map_inf_le s t

lemma is_closed_of_closure_subset {s : set Œ±} (h : closure s ‚äÜ s) : is_closed s :=
by rw subset.antisymm subset_closure h; exact is_closed_closure

lemma closure_eq_iff_is_closed {s : set Œ±} : closure s = s ‚Üî is_closed s :=
‚ü®assume h, h ‚ñ∏ is_closed_closure, is_closed.closure_eq‚ü©

lemma closure_subset_iff_is_closed {s : set Œ±} : closure s ‚äÜ s ‚Üî is_closed s :=
‚ü®is_closed_of_closure_subset, is_closed.closure_subset‚ü©

@[simp] lemma closure_empty : closure (‚àÖ : set Œ±) = ‚àÖ :=
is_closed_empty.closure_eq

@[simp] lemma closure_empty_iff (s : set Œ±) : closure s = ‚àÖ ‚Üî s = ‚àÖ :=
‚ü®subset_eq_empty subset_closure, Œª h, h.symm ‚ñ∏ closure_empty‚ü©

lemma set.nonempty.closure {s : set Œ±} (h : s.nonempty) :
  set.nonempty (closure s) :=
let ‚ü®x, hx‚ü© := h in ‚ü®x, subset_closure hx‚ü©

@[simp] lemma closure_univ : closure (univ : set Œ±) = univ :=
is_closed_univ.closure_eq

@[simp] lemma closure_closure {s : set Œ±} : closure (closure s) = closure s :=
is_closed_closure.closure_eq

@[simp] lemma closure_union {s t : set Œ±} : closure (s ‚à™ t) = closure s ‚à™ closure t :=
subset.antisymm
  (closure_minimal (union_subset_union subset_closure subset_closure) $ is_closed_union is_closed_closure is_closed_closure)
  ((monotone_closure Œ±).le_map_sup s t)

lemma interior_subset_closure {s : set Œ±} : interior s ‚äÜ closure s :=
subset.trans interior_subset subset_closure

lemma closure_eq_compl_interior_compl {s : set Œ±} : closure s = (interior s·∂ú)·∂ú :=
begin
  unfold interior closure is_closed,
  rw [compl_sUnion, compl_image_set_of],
  simp only [compl_subset_compl]
end

@[simp] lemma interior_compl {s : set Œ±} : interior s·∂ú = (closure s)·∂ú :=
by simp [closure_eq_compl_interior_compl]

@[simp] lemma closure_compl {s : set Œ±} : closure s·∂ú = (interior s)·∂ú :=
by simp [closure_eq_compl_interior_compl]

theorem mem_closure_iff {s : set Œ±} {a : Œ±} :
  a ‚àà closure s ‚Üî ‚àÄ o, is_open o ‚Üí a ‚àà o ‚Üí (o ‚à© s).nonempty :=
‚ü®Œª h o oo ao, classical.by_contradiction $ Œª os,
  have s ‚äÜ o·∂ú, from Œª x xs xo, os ‚ü®x, xo, xs‚ü©,
  closure_minimal this (is_closed_compl_iff.2 oo) h ao,
Œª H c ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, classical.by_contradiction $ Œª nc,
  let ‚ü®x, hc, hs‚ü© := (H _ h‚ÇÅ nc) in hc (h‚ÇÇ hs)‚ü©

/-- A set is dense in a topological space if every point belongs to its closure. -/
def dense (s : set Œ±) : Prop := ‚àÄ x, x ‚àà closure s

lemma dense_iff_closure_eq {s : set Œ±} : dense s ‚Üî closure s = univ :=
eq_univ_iff_forall.symm

lemma dense.closure_eq {s : set Œ±} (h : dense s) : closure s = univ :=
dense_iff_closure_eq.mp h

/-- The closure of a set `s` is dense if and only if `s` is dense. -/
@[simp] lemma dense_closure {s : set Œ±} : dense (closure s) ‚Üî dense s :=
by rw [dense, dense, closure_closure]

alias dense_closure ‚Üî dense.of_closure dense.closure

@[simp] lemma dense_univ : dense (univ : set Œ±) := Œª x, subset_closure trivial

/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/
lemma dense_iff_inter_open {s : set Œ±} :
  dense s ‚Üî ‚àÄ U, is_open U ‚Üí U.nonempty ‚Üí (U ‚à© s).nonempty :=
begin
  split ; intro h,
  { rintros U U_op ‚ü®x, x_in‚ü©,
    exact mem_closure_iff.1 (by simp only [h.closure_eq]) U U_op x_in },
  { intro x,
    rw mem_closure_iff,
    intros U U_op x_in,
    exact h U U_op ‚ü®_, x_in‚ü© },
end

alias dense_iff_inter_open ‚Üî dense.inter_open_nonempty _

lemma dense.nonempty_iff {s : set Œ±} (hs : dense s) :
  s.nonempty ‚Üî nonempty Œ± :=
‚ü®Œª ‚ü®x, hx‚ü©, ‚ü®x‚ü©, Œª ‚ü®x‚ü©,
  let ‚ü®y, hy‚ü© := hs.inter_open_nonempty _ is_open_univ ‚ü®x, trivial‚ü© in ‚ü®y, hy.2‚ü©‚ü©

lemma dense.nonempty [h : nonempty Œ±] {s : set Œ±} (hs : dense s) : s.nonempty :=
hs.nonempty_iff.2 h

@[mono]
lemma dense.mono {s‚ÇÅ s‚ÇÇ : set Œ±} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) (hd : dense s‚ÇÅ) : dense s‚ÇÇ :=
Œª x, closure_mono h (hd x)

/-!
### Frontier of a set
-/

/-- The frontier of a set is the set of points between the closure and interior. -/
def frontier (s : set Œ±) : set Œ± := closure s \ interior s

lemma frontier_eq_closure_inter_closure {s : set Œ±} :
  frontier s = closure s ‚à© closure s·∂ú :=
by rw [closure_compl, frontier, diff_eq]

/-- The complement of a set has the same frontier as the original set. -/
@[simp] lemma frontier_compl (s : set Œ±) : frontier s·∂ú = frontier s :=
by simp only [frontier_eq_closure_inter_closure, compl_compl, inter_comm]

lemma frontier_inter_subset (s t : set Œ±) :
  frontier (s ‚à© t) ‚äÜ (frontier s ‚à© closure t) ‚à™ (closure s ‚à© frontier t) :=
begin
  simp only [frontier_eq_closure_inter_closure, compl_inter, closure_union],
  convert inter_subset_inter_left _ (closure_inter_subset_inter_closure s t),
  simp only [inter_distrib_left, inter_distrib_right, inter_assoc],
  congr' 2,
  apply inter_comm
end

lemma frontier_union_subset (s t : set Œ±) :
  frontier (s ‚à™ t) ‚äÜ (frontier s ‚à© closure t·∂ú) ‚à™ (closure s·∂ú ‚à© frontier t) :=
by simpa only [frontier_compl, ‚Üê compl_union]
  using frontier_inter_subset s·∂ú t·∂ú

lemma is_closed.frontier_eq {s : set Œ±} (hs : is_closed s) : frontier s = s \ interior s :=
by rw [frontier, hs.closure_eq]

lemma is_open.frontier_eq {s : set Œ±} (hs : is_open s) : frontier s = closure s \ s :=
by rw [frontier, hs.interior_eq]

/-- The frontier of a set is closed. -/
lemma is_closed_frontier {s : set Œ±} : is_closed (frontier s) :=
by rw frontier_eq_closure_inter_closure; exact is_closed_inter is_closed_closure is_closed_closure

/-- The frontier of a closed set has no interior point. -/
lemma interior_frontier {s : set Œ±} (h : is_closed s) : interior (frontier s) = ‚àÖ :=
begin
  have A : frontier s = s \ interior s, from h.frontier_eq,
  have B : interior (frontier s) ‚äÜ interior s, by rw A; exact interior_mono (diff_subset _ _),
  have C : interior (frontier s) ‚äÜ frontier s := interior_subset,
  have : interior (frontier s) ‚äÜ (interior s) ‚à© (s \ interior s) :=
    subset_inter B (by simpa [A] using C),
  rwa [inter_diff_self, subset_empty_iff] at this,
end

lemma closure_eq_interior_union_frontier (s : set Œ±) : closure s = interior s ‚à™ frontier s :=
(union_diff_cancel interior_subset_closure).symm

lemma closure_eq_self_union_frontier (s : set Œ±) : closure s = s ‚à™ frontier s :=
(union_diff_cancel' interior_subset subset_closure).symm

/-!
###¬†Neighborhoods
-/

/-- A set is called a neighborhood of `a` if it contains an open set around `a`. The set of all
neighborhoods of `a` forms a filter, the neighborhood filter at `a`, is here defined as the
infimum over the principal filters of all open sets containing `a`. -/
def nhds (a : Œ±) : filter Œ± := (‚®Ö s ‚àà {s : set Œ± | a ‚àà s ‚àß is_open s}, ùìü s)

localized "notation `ùìù` := nhds" in topological_space

lemma nhds_def (a : Œ±) : ùìù a = (‚®Ö s ‚àà {s : set Œ± | a ‚àà s ‚àß is_open s}, ùìü s) := rfl

/-- The open sets containing `a` are a basis for the neighborhood filter. See `nhds_basis_opens'`
for a variant using open neighborhoods instead. -/
lemma nhds_basis_opens (a : Œ±) : (ùìù a).has_basis (Œª s : set Œ±, a ‚àà s ‚àß is_open s) (Œª x, x) :=
has_basis_binfi_principal
  (Œª s ‚ü®has, hs‚ü© t ‚ü®hat, ht‚ü©, ‚ü®s ‚à© t, ‚ü®‚ü®has, hat‚ü©, is_open_inter hs ht‚ü©,
    ‚ü®inter_subset_left _ _, inter_subset_right _ _‚ü©‚ü©)
  ‚ü®univ, ‚ü®mem_univ a, is_open_univ‚ü©‚ü©

/-- A filter lies below the neighborhood filter at `a` iff it contains every open set around `a`. -/
lemma le_nhds_iff {f a} : f ‚â§ ùìù a ‚Üî ‚àÄ s : set Œ±, a ‚àà s ‚Üí is_open s ‚Üí s ‚àà f :=
by simp [nhds_def]

/-- To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above
the principal filter of some open set `s` containing `a`. -/
lemma nhds_le_of_le {f a} {s : set Œ±} (h : a ‚àà s) (o : is_open s) (sf : ùìü s ‚â§ f) : ùìù a ‚â§ f :=
by rw nhds_def; exact infi_le_of_le s (infi_le_of_le ‚ü®h, o‚ü© sf)

lemma mem_nhds_sets_iff {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù a ‚Üî ‚àÉt‚äÜs, is_open t ‚àß a ‚àà t :=
(nhds_basis_opens a).mem_iff.trans
  ‚ü®Œª ‚ü®t, ‚ü®hat, ht‚ü©, hts‚ü©, ‚ü®t, hts, ht, hat‚ü©, Œª ‚ü®t, hts, ht, hat‚ü©, ‚ü®t, ‚ü®hat, ht‚ü©, hts‚ü©‚ü©

/-- A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set
containing `a`. -/
lemma eventually_nhds_iff {a : Œ±} {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂† x in ùìù a, p x) ‚Üî ‚àÉ (t : set Œ±), (‚àÄ x ‚àà t, p x) ‚àß is_open t ‚àß a ‚àà t :=
mem_nhds_sets_iff.trans $ by simp only [subset_def, exists_prop, mem_set_of_eq]

lemma map_nhds {a : Œ±} {f : Œ± ‚Üí Œ≤} :
  map f (ùìù a) = (‚®Ö s ‚àà {s : set Œ± | a ‚àà s ‚àß is_open s}, ùìü (image f s)) :=
((nhds_basis_opens a).map f).eq_binfi

attribute [irreducible] nhds

lemma mem_of_nhds {a : Œ±} {s : set Œ±} : s ‚àà ùìù a ‚Üí a ‚àà s :=
Œª H, let ‚ü®t, ht, _, hs‚ü© := mem_nhds_sets_iff.1 H in ht hs

/-- If a predicate is true in a neighborhood of `a`, then it is true for `a`. -/
lemma filter.eventually.self_of_nhds {p : Œ± ‚Üí Prop} {a : Œ±}
  (h : ‚àÄ·∂† y in ùìù a, p y) : p a :=
mem_of_nhds h

lemma mem_nhds_sets {a : Œ±} {s : set Œ±} (hs : is_open s) (ha : a ‚àà s) :
  s ‚àà ùìù a :=
mem_nhds_sets_iff.2 ‚ü®s, subset.refl _, hs, ha‚ü©

lemma is_open.eventually_mem {a : Œ±} {s : set Œ±} (hs : is_open s) (ha : a ‚àà s) :
  ‚àÄ·∂† x in ùìù a, x ‚àà s :=
mem_nhds_sets hs ha

/-- The open neighborhoods of `a` are a basis for the neighborhood filter. See `nhds_basis_opens`
for a variant using open sets around `a` instead. -/
lemma nhds_basis_opens' (a : Œ±) : (ùìù a).has_basis (Œª s : set Œ±, s ‚àà ùìù a ‚àß is_open s) (Œª x, x) :=
begin
  convert nhds_basis_opens a,
  ext s,
  split,
  { rintros ‚ü®s_in, s_op‚ü©,
    exact ‚ü®mem_of_nhds s_in, s_op‚ü© },
  { rintros ‚ü®a_in, s_op‚ü©,
    exact ‚ü®mem_nhds_sets s_op a_in, s_op‚ü© },
end

/-- If a predicate is true in a neighbourhood of `a`, then for `y` sufficiently close
to `a` this predicate is true in a neighbourhood of `y`. -/
lemma filter.eventually.eventually_nhds {p : Œ± ‚Üí Prop} {a : Œ±} (h : ‚àÄ·∂† y in ùìù a, p y) :
  ‚àÄ·∂† y in ùìù a, ‚àÄ·∂† x in ùìù y, p x :=
let ‚ü®t, htp, hto, ha‚ü© := eventually_nhds_iff.1 h in
eventually_nhds_iff.2 ‚ü®t, Œª x hx, eventually_nhds_iff.2 ‚ü®t, htp, hto, hx‚ü©, hto, ha‚ü©

@[simp] lemma eventually_eventually_nhds {p : Œ± ‚Üí Prop} {a : Œ±} :
  (‚àÄ·∂† y in ùìù a, ‚àÄ·∂† x in ùìù y, p x) ‚Üî ‚àÄ·∂† x in ùìù a, p x :=
‚ü®Œª h, h.self_of_nhds, Œª h, h.eventually_nhds‚ü©

@[simp] lemma nhds_bind_nhds : (ùìù a).bind ùìù = ùìù a := filter.ext $ Œª s, eventually_eventually_nhds

@[simp] lemma eventually_eventually_eq_nhds {f g : Œ± ‚Üí Œ≤} {a : Œ±} :
  (‚àÄ·∂† y in ùìù a, f =·∂†[ùìù y] g) ‚Üî f =·∂†[ùìù a] g :=
eventually_eventually_nhds

lemma filter.eventually_eq.eq_of_nhds {f g : Œ± ‚Üí Œ≤} {a : Œ±} (h : f =·∂†[ùìù a] g) : f a = g a :=
h.self_of_nhds

@[simp] lemma eventually_eventually_le_nhds [has_le Œ≤] {f g : Œ± ‚Üí Œ≤} {a : Œ±} :
  (‚àÄ·∂† y in ùìù a, f ‚â§·∂†[ùìù y] g) ‚Üî f ‚â§·∂†[ùìù a] g :=
eventually_eventually_nhds

/-- If two functions are equal in a neighbourhood of `a`, then for `y` sufficiently close
to `a` these functions are equal in a neighbourhood of `y`. -/
lemma filter.eventually_eq.eventually_eq_nhds {f g : Œ± ‚Üí Œ≤} {a : Œ±} (h : f =·∂†[ùìù a] g) :
  ‚àÄ·∂† y in ùìù a, f =·∂†[ùìù y] g :=
h.eventually_nhds

/-- If `f x ‚â§ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have
`f x ‚â§ g x` in a neighbourhood of `y`. -/
lemma filter.eventually_le.eventually_le_nhds [has_le Œ≤] {f g : Œ± ‚Üí Œ≤} {a : Œ±} (h : f ‚â§·∂†[ùìù a] g) :
  ‚àÄ·∂† y in ùìù a, f ‚â§·∂†[ùìù y] g :=
h.eventually_nhds

theorem all_mem_nhds (x : Œ±) (P : set Œ± ‚Üí Prop) (hP : ‚àÄ s t, s ‚äÜ t ‚Üí P s ‚Üí P t) :
  (‚àÄ s ‚àà ùìù x, P s) ‚Üî (‚àÄ s, is_open s ‚Üí x ‚àà s ‚Üí P s) :=
((nhds_basis_opens x).forall_iff hP).trans $ by simp only [and_comm (x ‚àà _), and_imp]

theorem all_mem_nhds_filter (x : Œ±) (f : set Œ± ‚Üí set Œ≤) (hf : ‚àÄ s t, s ‚äÜ t ‚Üí f s ‚äÜ f t)
    (l : filter Œ≤) :
  (‚àÄ s ‚àà ùìù x, f s ‚àà l) ‚Üî (‚àÄ s, is_open s ‚Üí x ‚àà s ‚Üí f s ‚àà l) :=
all_mem_nhds _ _ (Œª s t ssubt h, mem_sets_of_superset h (hf s t ssubt))

theorem rtendsto_nhds {r : rel Œ≤ Œ±} {l : filter Œ≤} {a : Œ±} :
  rtendsto r l (ùìù a) ‚Üî (‚àÄ s, is_open s ‚Üí a ‚àà s ‚Üí r.core s ‚àà l) :=
all_mem_nhds_filter _ _ (Œª s t, id) _

theorem rtendsto'_nhds {r : rel Œ≤ Œ±} {l : filter Œ≤} {a : Œ±} :
  rtendsto' r l (ùìù a) ‚Üî (‚àÄ s, is_open s ‚Üí a ‚àà s ‚Üí r.preimage s ‚àà l) :=
by { rw [rtendsto'_def], apply all_mem_nhds_filter, apply rel.preimage_mono }

theorem ptendsto_nhds {f : Œ≤ ‚Üí. Œ±} {l : filter Œ≤} {a : Œ±} :
  ptendsto f l (ùìù a) ‚Üî (‚àÄ s, is_open s ‚Üí a ‚àà s ‚Üí f.core s ‚àà l) :=
rtendsto_nhds

theorem ptendsto'_nhds {f : Œ≤ ‚Üí. Œ±} {l : filter Œ≤} {a : Œ±} :
  ptendsto' f l (ùìù a) ‚Üî (‚àÄ s, is_open s ‚Üí a ‚àà s ‚Üí f.preimage s ‚àà l) :=
rtendsto'_nhds

theorem tendsto_nhds {f : Œ≤ ‚Üí Œ±} {l : filter Œ≤} {a : Œ±} :
  tendsto f l (ùìù a) ‚Üî (‚àÄ s, is_open s ‚Üí a ‚àà s ‚Üí f ‚Åª¬π' s ‚àà l) :=
all_mem_nhds_filter _ _ (Œª s t h, preimage_mono h) _

lemma tendsto_const_nhds {a : Œ±} {f : filter Œ≤} : tendsto (Œªb:Œ≤, a) f (ùìù a) :=
tendsto_nhds.mpr $ assume s hs ha, univ_mem_sets' $ assume _, ha

lemma pure_le_nhds : pure ‚â§ (ùìù : Œ± ‚Üí filter Œ±) :=
assume a s hs, mem_pure_sets.2 $ mem_of_nhds hs

lemma tendsto_pure_nhds {Œ± : Type*} [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (a : Œ±) :
  tendsto f (pure a) (ùìù (f a)) :=
(tendsto_pure_pure f a).mono_right (pure_le_nhds _)

lemma order_top.tendsto_at_top_nhds {Œ± : Type*} [order_top Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) :
  tendsto f at_top (ùìù $ f ‚ä§) :=
(tendsto_at_top_pure f).mono_right (pure_le_nhds _)

@[simp] instance nhds_ne_bot {a : Œ±} : ne_bot (ùìù a) :=
ne_bot_of_le (pure_le_nhds a)

/-!
### Cluster points

In this section we define [cluster points](https://en.wikipedia.org/wiki/Limit_point)
(also known as limit points and accumulation points) of a filter and of a sequence.
-/

/-- A point `x` is a cluster point of a filter `F` if ùìù x ‚äì F ‚â† ‚ä•. Also known as
an accumulation point or a limit point. -/
def cluster_pt (x : Œ±) (F : filter Œ±) : Prop := ne_bot (ùìù x ‚äì F)

lemma cluster_pt.ne_bot {x : Œ±} {F : filter Œ±} (h : cluster_pt x F) : ne_bot (ùìù x ‚äì F) := h

lemma cluster_pt_iff {x : Œ±} {F : filter Œ±} :
  cluster_pt x F ‚Üî ‚àÄ {U V : set Œ±}, U ‚àà ùìù x ‚Üí V ‚àà F ‚Üí (U ‚à© V).nonempty :=
inf_ne_bot_iff

/-- `x` is a cluster point of a set `s` if every neighbourhood of `x` meets `s` on a nonempty
set. -/
lemma cluster_pt_principal_iff {x : Œ±} {s : set Œ±} :
  cluster_pt x (ùìü s) ‚Üî ‚àÄ U ‚àà ùìù x, (U ‚à© s).nonempty :=
inf_principal_ne_bot_iff

lemma cluster_pt_principal_iff_frequently {x : Œ±} {s : set Œ±} :
  cluster_pt x (ùìü s) ‚Üî ‚àÉ·∂† y in ùìù x, y ‚àà s :=
by simp only [cluster_pt_principal_iff, frequently_iff, set.nonempty, exists_prop, mem_inter_iff]

lemma cluster_pt.of_le_nhds {x : Œ±} {f : filter Œ±} (H : f ‚â§ ùìù x) [ne_bot f] : cluster_pt x f :=
by rwa [cluster_pt, inf_eq_right.mpr H]

lemma cluster_pt.of_le_nhds' {x : Œ±} {f : filter Œ±} (H : f ‚â§ ùìù x) (hf : ne_bot f) :
  cluster_pt x f :=
cluster_pt.of_le_nhds H

lemma cluster_pt.of_nhds_le {x : Œ±} {f : filter Œ±} (H : ùìù x ‚â§ f) : cluster_pt x f :=
by simp only [cluster_pt, inf_eq_left.mpr H, nhds_ne_bot]

lemma cluster_pt.mono {x : Œ±} {f g : filter Œ±} (H : cluster_pt x f) (h : f ‚â§ g) :
  cluster_pt x g :=
ne_bot_of_le_ne_bot H $ inf_le_inf_left _ h

lemma cluster_pt.of_inf_left {x : Œ±} {f g : filter Œ±} (H : cluster_pt x $ f ‚äì g) :
  cluster_pt x f :=
H.mono inf_le_left

lemma cluster_pt.of_inf_right {x : Œ±} {f g : filter Œ±} (H : cluster_pt x $ f ‚äì g) :
  cluster_pt x g :=
H.mono inf_le_right

/-- A point `x` is a cluster point of a sequence `u` along a filter `F` if it is a cluster point
of `map u F`. -/
def map_cluster_pt {Œπ :Type*} (x : Œ±) (F : filter Œπ) (u : Œπ ‚Üí Œ±) : Prop := cluster_pt x (map u F)

lemma map_cluster_pt_iff {Œπ :Type*} (x : Œ±) (F : filter Œπ) (u : Œπ ‚Üí Œ±) :
  map_cluster_pt x F u ‚Üî ‚àÄ s ‚àà ùìù x, ‚àÉ·∂† a in F, u a ‚àà s :=
by { simp_rw [map_cluster_pt, cluster_pt, inf_ne_bot_iff_frequently_left, frequently_map], refl }

lemma map_cluster_pt_of_comp {Œπ Œ¥ :Type*} {F : filter Œπ} {œÜ : Œ¥ ‚Üí Œπ} {p : filter Œ¥}
  {x : Œ±} {u : Œπ ‚Üí Œ±} [ne_bot p] (h : tendsto œÜ p F) (H : tendsto (u ‚àò œÜ) p (ùìù x)) :
  map_cluster_pt x F u :=
begin
  have := calc
  map (u ‚àò œÜ) p = map u (map œÜ p) : map_map
  ... ‚â§ map u F : map_mono h,
  have : map (u ‚àò œÜ) p ‚â§ ùìù x ‚äì map u F,
    from le_inf H this,
  exact ne_bot_of_le this
end

/-!
### Interior, closure and frontier in terms of neighborhoods
-/

lemma interior_eq_nhds {s : set Œ±} : interior s = {a | ùìù a ‚â§ ùìü s} :=
set.ext $ Œª x, by simp only [mem_interior, le_principal_iff, mem_nhds_sets_iff]; refl

lemma mem_interior_iff_mem_nhds {s : set Œ±} {a : Œ±} :
  a ‚àà interior s ‚Üî s ‚àà ùìù a :=
by simp only [interior_eq_nhds, le_principal_iff]; refl

lemma subset_interior_iff_nhds {s V : set Œ±} : s ‚äÜ interior V ‚Üî ‚àÄ x ‚àà s, V ‚àà ùìù x :=
show (‚àÄ x, x ‚àà s ‚Üí  x ‚àà _) ‚Üî _, by simp_rw mem_interior_iff_mem_nhds

lemma is_open_iff_nhds {s : set Œ±} : is_open s ‚Üî ‚àÄa‚ààs, ùìù a ‚â§ ùìü s :=
calc is_open s ‚Üî s ‚äÜ interior s : subset_interior_iff_open.symm
  ... ‚Üî (‚àÄa‚ààs, ùìù a ‚â§ ùìü s) : by rw [interior_eq_nhds]; refl

lemma is_open_iff_mem_nhds {s : set Œ±} : is_open s ‚Üî ‚àÄa‚ààs, s ‚àà ùìù a :=
is_open_iff_nhds.trans $ forall_congr $ Œª _, imp_congr_right $ Œª _, le_principal_iff

theorem is_open_iff_ultrafilter {s : set Œ±} :
  is_open s ‚Üî (‚àÄ (x ‚àà s) (l : filter Œ±), is_ultrafilter l ‚Üí l ‚â§ ùìù x ‚Üí s ‚àà l) :=
by simp_rw [is_open_iff_mem_nhds, @mem_iff_ultrafilter _ (ùìù _)]

lemma mem_closure_iff_frequently {s : set Œ±} {a : Œ±} : a ‚àà closure s ‚Üî ‚àÉ·∂† x in ùìù a, x ‚àà s :=
by rw [filter.frequently, filter.eventually, ‚Üê mem_interior_iff_mem_nhds,
  closure_eq_compl_interior_compl]; refl

alias mem_closure_iff_frequently ‚Üî _ filter.frequently.mem_closure

theorem mem_closure_iff_cluster_pt {s : set Œ±} {a : Œ±} : a ‚àà closure s ‚Üî cluster_pt a (ùìü s) :=
mem_closure_iff_frequently.trans cluster_pt_principal_iff_frequently.symm

lemma closure_eq_cluster_pts {s : set Œ±} : closure s = {a | cluster_pt a (ùìü s)} :=
set.ext $ Œª x, mem_closure_iff_cluster_pt

theorem mem_closure_iff_nhds {s : set Œ±} {a : Œ±} :
  a ‚àà closure s ‚Üî ‚àÄ t ‚àà ùìù a, (t ‚à© s).nonempty :=
mem_closure_iff_cluster_pt.trans cluster_pt_principal_iff

theorem mem_closure_iff_nhds' {s : set Œ±} {a : Œ±} :
  a ‚àà closure s ‚Üî ‚àÄ t ‚àà ùìù a, ‚àÉ y : s, ‚Üëy ‚àà t :=
by simp only [mem_closure_iff_nhds, set.nonempty_inter_iff_exists_right]

theorem mem_closure_iff_comap_ne_bot {A : set Œ±} {x : Œ±} :
  x ‚àà closure A ‚Üî ne_bot (comap (coe : A ‚Üí Œ±) (ùìù x)) :=
by simp_rw [mem_closure_iff_nhds, comap_ne_bot_iff, set.nonempty_inter_iff_exists_right]

theorem mem_closure_iff_nhds_basis {a : Œ±} {p : Œ≤ ‚Üí Prop} {s : Œ≤ ‚Üí set Œ±} (h : (ùìù a).has_basis p s)
  {t : set Œ±} :
  a ‚àà closure t ‚Üî ‚àÄ i, p i ‚Üí ‚àÉ y ‚àà t, y ‚àà s i :=
mem_closure_iff_nhds.trans
  ‚ü®Œª H i hi, let ‚ü®x, hx‚ü© := (H _ $ h.mem_of_mem hi) in ‚ü®x, hx.2, hx.1‚ü©,
    Œª H t' ht', let ‚ü®i, hi, hit‚ü© := h.mem_iff.1 ht', ‚ü®x, xt, hx‚ü© := H i hi in
    ‚ü®x, hit hx, xt‚ü©‚ü©

/-- `x` belongs to the closure of `s` if and only if some ultrafilter
  supported on `s` converges to `x`. -/
lemma mem_closure_iff_ultrafilter {s : set Œ±} {x : Œ±} :
  x ‚àà closure s ‚Üî ‚àÉ (u : ultrafilter Œ±), s ‚àà u.val ‚àß u.val ‚â§ ùìù x :=
begin
  rw closure_eq_cluster_pts, change cluster_pt x (ùìü s) ‚Üî _, symmetry,
  convert exists_ultrafilter_iff _, ext u,
  rw [‚Üêle_principal_iff, inf_comm, le_inf_iff]
end

lemma is_closed_iff_cluster_pt {s : set Œ±} : is_closed s ‚Üî ‚àÄa, cluster_pt a (ùìü s) ‚Üí a ‚àà s :=
calc is_closed s ‚Üî closure s ‚äÜ s : closure_subset_iff_is_closed.symm
  ... ‚Üî (‚àÄa, cluster_pt a (ùìü s) ‚Üí a ‚àà s) : by simp only [subset_def, mem_closure_iff_cluster_pt]

lemma is_closed_iff_nhds {s : set Œ±} : is_closed s ‚Üî ‚àÄ x, (‚àÄ U ‚àà ùìù x, (U ‚à© s).nonempty) ‚Üí x ‚àà s :=
by simp_rw [is_closed_iff_cluster_pt, cluster_pt, inf_principal_ne_bot_iff]

lemma closure_inter_open {s t : set Œ±} (h : is_open s) : s ‚à© closure t ‚äÜ closure (s ‚à© t) :=
assume a ‚ü®hs, ht‚ü©,
have s ‚àà ùìù a, from mem_nhds_sets h hs,
have ùìù a ‚äì ùìü s = ùìù a, by rwa [inf_eq_left, le_principal_iff],
have cluster_pt a (ùìü (s ‚à© t)),
  from calc ùìù a ‚äì ùìü (s ‚à© t) = ùìù a ‚äì (ùìü s ‚äì ùìü t) : by rw inf_principal
    ... = ùìù a ‚äì ùìü t : by rw [‚Üêinf_assoc, this]
    ... ‚â† ‚ä• : by rw [closure_eq_cluster_pts] at ht; assumption,
by rwa [closure_eq_cluster_pts]

/-- The intersection of an open dense set with a dense set is a dense set. -/
lemma dense.inter_of_open_left {s t : set Œ±} (hs : dense s) (ht : dense t) (hso : is_open s) :
  dense (s ‚à© t) :=
Œª x, (closure_minimal (closure_inter_open hso) is_closed_closure) $
  by simp [hs.closure_eq, ht.closure_eq]

/-- The intersection of a dense set with an open dense set is a dense set. -/
lemma dense.inter_of_open_right {s t : set Œ±} (hs : dense s) (ht : dense t) (hto : is_open t) :
  dense (s ‚à© t) :=
inter_comm t s ‚ñ∏ ht.inter_of_open_left hs hto

lemma closure_diff {s t : set Œ±} : closure s \ closure t ‚äÜ closure (s \ t) :=
calc closure s \ closure t = (closure t)·∂ú ‚à© closure s : by simp only [diff_eq, inter_comm]
  ... ‚äÜ closure ((closure t)·∂ú ‚à© s) : closure_inter_open $ is_open_compl_iff.mpr $ is_closed_closure
  ... = closure (s \ closure t) : by simp only [diff_eq, inter_comm]
  ... ‚äÜ closure (s \ t) : closure_mono $ diff_subset_diff (subset.refl s) subset_closure

lemma filter.frequently.mem_of_closed {a : Œ±} {s : set Œ±} (h : ‚àÉ·∂† x in ùìù a, x ‚àà s)
  (hs : is_closed s) : a ‚àà s :=
hs.closure_subset h.mem_closure

lemma is_closed.mem_of_frequently_of_tendsto {f : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±} {s : set Œ±}
  (hs : is_closed s) (h : ‚àÉ·∂† x in b, f x ‚àà s) (hf : tendsto f b (ùìù a)) : a ‚àà s :=
(hf.frequently $ show ‚àÉ·∂† x in b, (Œª y, y ‚àà s) (f x), from h).mem_of_closed hs

lemma is_closed.mem_of_tendsto {f : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±} {s : set Œ±}
  [ne_bot b] (hs : is_closed s) (hf : tendsto f b (ùìù a)) (h : ‚àÄ·∂† x in b, f x ‚àà s) : a ‚àà s :=
hs.mem_of_frequently_of_tendsto h.frequently hf

lemma mem_closure_of_tendsto {f : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±} {s : set Œ±}
  [ne_bot b] (hf : tendsto f b (ùìù a)) (h : ‚àÄ·∂† x in b, f x ‚àà s) : a ‚àà closure s :=
is_closed_closure.mem_of_tendsto hf $ h.mono (preimage_mono subset_closure)

/-- Suppose that `f` sends the complement to `s` to a single point `a`, and `l` is some filter.
Then `f` tends to `a` along `l` restricted to `s` if and only if it tends to `a` along `l`. -/
lemma tendsto_inf_principal_nhds_iff_of_forall_eq {f : Œ≤ ‚Üí Œ±} {l : filter Œ≤} {s : set Œ≤}
  {a : Œ±} (h : ‚àÄ x ‚àâ s, f x = a) :
  tendsto f (l ‚äì ùìü s) (ùìù a) ‚Üî tendsto f l (ùìù a) :=
begin
  rw [tendsto_iff_comap, tendsto_iff_comap],
  replace h : ùìü s·∂ú ‚â§ comap f (ùìù a),
  { rintros U ‚ü®t, ht, htU‚ü© x hx,
    have : f x ‚àà t, from (h x hx).symm ‚ñ∏ mem_of_nhds ht,
    exact htU this },
  refine ‚ü®Œª h', _, le_trans inf_le_left‚ü©,
  have := sup_le h' h,
  rw [sup_inf_right, sup_principal, union_compl_self, principal_univ,
    inf_top_eq, sup_le_iff] at this,
  exact this.1
end

/-!
### Limits of filters in topological spaces
-/

section lim

/-- If `f` is a filter, then `Lim f` is a limit of the filter, if it exists. -/
noncomputable def Lim [nonempty Œ±] (f : filter Œ±) : Œ± := epsilon $ Œªa, f ‚â§ ùìù a

/--
If `f` is a filter satisfying `ne_bot f`, then `Lim' f` is a limit of the filter, if it exists.
-/
def Lim' (f : filter Œ±) [ne_bot f] : Œ± := @Lim _ _ (nonempty_of_ne_bot f) f

-- Note: `ultrafilter` is inside the `filter` namespace.
/--
If `F` is an ultrafilter, then `filter.ultrafilter.Lim F` is a limit of the filter, if it exists.
Note that dot notation `F.Lim` can be used for `F : ultrafilter Œ±`.
-/
def filter.ultrafilter.Lim : ultrafilter Œ± ‚Üí Œ± := Œª F, Lim' F.1

/-- If `f` is a filter in `Œ≤` and `g : Œ≤ ‚Üí Œ±` is a function, then `lim f` is a limit of `g` at `f`,
if it exists. -/
noncomputable def lim [nonempty Œ±] (f : filter Œ≤) (g : Œ≤ ‚Üí Œ±) : Œ± :=
Lim (f.map g)

/-- If a filter `f` is majorated by some `ùìù a`, then it is majorated by `ùìù (Lim f)`. We formulate
this lemma with a `[nonempty Œ±]` argument of `Lim` derived from `h` to make it useful for types
without a `[nonempty Œ±]` instance. Because of the built-in proof irrelevance, Lean will unify
this instance with any other instance. -/
lemma le_nhds_Lim {f : filter Œ±} (h : ‚àÉa, f ‚â§ ùìù a) : f ‚â§ ùìù (@Lim _ _ (nonempty_of_exists h) f) :=
epsilon_spec h

/-- If `g` tends to some `ùìù a` along `f`, then it tends to `ùìù (lim f g)`. We formulate
this lemma with a `[nonempty Œ±]` argument of `lim` derived from `h` to make it useful for types
without a `[nonempty Œ±]` instance. Because of the built-in proof irrelevance, Lean will unify
this instance with any other instance. -/
lemma tendsto_nhds_lim {f : filter Œ≤} {g : Œ≤ ‚Üí Œ±} (h : ‚àÉ a, tendsto g f (ùìù a)) :
  tendsto g f (ùìù $ @lim _ _ _ (nonempty_of_exists h) f g) :=
le_nhds_Lim h

end lim

/-!
###¬†Locally finite families
-/

/- locally finite family [General Topology (Bourbaki, 1995)] -/
section locally_finite

/-- A family of sets in `set Œ±` is locally finite if at every point `x:Œ±`,
  there is a neighborhood of `x` which meets only finitely many sets in the family -/
def locally_finite (f : Œ≤ ‚Üí set Œ±) :=
‚àÄx:Œ±, ‚àÉt ‚àà ùìù x, finite {i | (f i ‚à© t).nonempty }

lemma locally_finite_of_finite {f : Œ≤ ‚Üí set Œ±} (h : finite (univ : set Œ≤)) : locally_finite f :=
assume x, ‚ü®univ, univ_mem_sets, h.subset $ subset_univ _‚ü©

lemma locally_finite_subset
  {f‚ÇÅ f‚ÇÇ : Œ≤ ‚Üí set Œ±} (hf‚ÇÇ : locally_finite f‚ÇÇ) (hf : ‚àÄb, f‚ÇÅ b ‚äÜ f‚ÇÇ b) : locally_finite f‚ÇÅ :=
assume a,
let ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := hf‚ÇÇ a in
‚ü®t, ht‚ÇÅ, ht‚ÇÇ.subset $ assume i hi, hi.mono $ inter_subset_inter (hf i) $ subset.refl _‚ü©

lemma is_closed_Union_of_locally_finite {f : Œ≤ ‚Üí set Œ±}
  (h‚ÇÅ : locally_finite f) (h‚ÇÇ : ‚àÄi, is_closed (f i)) : is_closed (‚ãÉi, f i) :=
is_open_iff_nhds.mpr $ assume a, assume h : a ‚àâ (‚ãÉi, f i),
  have ‚àÄi, a ‚àà (f i)·∂ú,
    from assume i hi, h $ mem_Union.2 ‚ü®i, hi‚ü©,
  have ‚àÄi, (f i)·∂ú ‚àà (ùìù a),
    by simp only [mem_nhds_sets_iff]; exact assume i, ‚ü®(f i)·∂ú, subset.refl _, h‚ÇÇ i, this i‚ü©,
  let ‚ü®t, h_sets, (h_fin : finite {i | (f i ‚à© t).nonempty })‚ü© := h‚ÇÅ a in

  calc ùìù a ‚â§ ùìü (t ‚à© (‚ãÇ i‚àà{i | (f i ‚à© t).nonempty }, (f i)·∂ú)) :
  begin
    rw [le_principal_iff],
    apply @filter.inter_mem_sets _ (ùìù a) _ _ h_sets,
    apply @filter.Inter_mem_sets _ (ùìù a) _ _ _ h_fin,
    exact assume i h, this i
  end
  ... ‚â§ ùìü (‚ãÉi, f i)·∂ú :
  begin
    simp only [principal_mono, subset_def, mem_compl_eq, mem_inter_eq,
      mem_Inter, mem_set_of_eq, mem_Union, and_imp, not_exists,
      exists_imp_distrib, ne_empty_iff_nonempty, set.nonempty],
    exact assume x xt ht i xfi, ht i x xfi xt xfi
  end

end locally_finite

end topological_space

/-!
### Continuity
-/

section continuous
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {Œ¥ : Type*}
variables [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥]
open_locale topological_space

/-- A function between topological spaces is continuous if the preimage
  of every open set is open. -/
def continuous (f : Œ± ‚Üí Œ≤) := ‚àÄs, is_open s ‚Üí is_open (f ‚Åª¬π' s)

lemma is_open.preimage {f : Œ± ‚Üí Œ≤} (hf : continuous f) {s : set Œ≤} (h : is_open s) :
  is_open (f ‚Åª¬π' s) :=
hf s h

/-- A function between topological spaces is continuous at a point `x‚ÇÄ`
if `f x` tends to `f x‚ÇÄ` when `x` tends to `x‚ÇÄ`. -/
def continuous_at (f : Œ± ‚Üí Œ≤) (x : Œ±) := tendsto f (ùìù x) (ùìù (f x))

lemma continuous_at.tendsto {f : Œ± ‚Üí Œ≤} {x : Œ±} (h : continuous_at f x) :
  tendsto f (ùìù x) (ùìù (f x)) :=
h

lemma continuous_at.preimage_mem_nhds {f : Œ± ‚Üí Œ≤} {x : Œ±} {t : set Œ≤} (h : continuous_at f x)
  (ht : t ‚àà ùìù (f x)) : f ‚Åª¬π' t ‚àà ùìù x :=
h ht

lemma preimage_interior_subset_interior_preimage {f : Œ± ‚Üí Œ≤} {s : set Œ≤}
  (hf : continuous f) : f‚Åª¬π' (interior s) ‚äÜ interior (f‚Åª¬π' s) :=
interior_maximal (preimage_mono interior_subset) (hf _ is_open_interior)

lemma continuous_id : continuous (id : Œ± ‚Üí Œ±) :=
assume s h, h

lemma continuous.comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : continuous g) (hf : continuous f) :
  continuous (g ‚àò f) :=
assume s h, hf _ (hg s h)

lemma continuous.iterate {f : Œ± ‚Üí Œ±} (h : continuous f) (n : ‚Ñï) : continuous (f^[n]) :=
nat.rec_on n continuous_id (Œª n ihn, ihn.comp h)

lemma continuous_at.comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {x : Œ±}
  (hg : continuous_at g (f x)) (hf : continuous_at f x) :
  continuous_at (g ‚àò f) x :=
hg.comp hf

lemma continuous.tendsto {f : Œ± ‚Üí Œ≤} (hf : continuous f) (x) :
  tendsto f (ùìù x) (ùìù (f x)) :=
((nhds_basis_opens x).tendsto_iff $ nhds_basis_opens $ f x).2 $
  Œª t ‚ü®hxt, ht‚ü©, ‚ü®f ‚Åª¬π' t, ‚ü®hxt, hf _ ht‚ü©, subset.refl _‚ü©

lemma continuous.continuous_at {f : Œ± ‚Üí Œ≤} {x : Œ±} (h : continuous f) :
  continuous_at f x :=
h.tendsto x

lemma continuous_iff_continuous_at {f : Œ± ‚Üí Œ≤} : continuous f ‚Üî ‚àÄ x, continuous_at f x :=
‚ü®continuous.tendsto,
  assume hf : ‚àÄx, tendsto f (ùìù x) (ùìù (f x)),
  assume s, assume hs : is_open s,
  have ‚àÄa, f a ‚àà s ‚Üí s ‚àà ùìù (f a),
    from Œª a ha, mem_nhds_sets hs ha,
  show is_open (f ‚Åª¬π' s),
    from is_open_iff_nhds.2 $ Œª a ha, le_principal_iff.2 $ hf _ (this a ha)‚ü©

lemma continuous_const {b : Œ≤} : continuous (Œªa:Œ±, b) :=
continuous_iff_continuous_at.mpr $ assume a, tendsto_const_nhds

lemma continuous_at_const {x : Œ±} {b : Œ≤} : continuous_at (Œª a:Œ±, b) x :=
continuous_const.continuous_at

lemma continuous_at_id {x : Œ±} : continuous_at id x :=
continuous_id.continuous_at

lemma continuous_at.iterate {f : Œ± ‚Üí Œ±} {x : Œ±} (hf : continuous_at f x) (hx : f x = x) (n : ‚Ñï) :
  continuous_at (f^[n]) x :=
nat.rec_on n continuous_at_id $ Œª n ihn,
show continuous_at (f^[n] ‚àò f) x,
from continuous_at.comp (hx.symm ‚ñ∏ ihn) hf

lemma continuous_iff_is_closed {f : Œ± ‚Üí Œ≤} :
  continuous f ‚Üî (‚àÄs, is_closed s ‚Üí is_closed (f ‚Åª¬π' s)) :=
‚ü®assume hf s hs, hf s·∂ú hs,
  assume hf s, by rw [‚Üêis_closed_compl_iff, ‚Üêis_closed_compl_iff]; exact hf _‚ü©

lemma is_closed.preimage {f : Œ± ‚Üí Œ≤} (hf : continuous f) {s : set Œ≤} (h : is_closed s) :
  is_closed (f ‚Åª¬π' s) :=
continuous_iff_is_closed.mp hf s h

lemma continuous_at_iff_ultrafilter {f : Œ± ‚Üí Œ≤} (x) : continuous_at f x ‚Üî
  ‚àÄ g, is_ultrafilter g ‚Üí g ‚â§ ùìù x ‚Üí g.map f ‚â§ ùìù (f x) :=
tendsto_iff_ultrafilter f (ùìù x) (ùìù (f x))

lemma continuous_iff_ultrafilter {f : Œ± ‚Üí Œ≤} :
  continuous f ‚Üî ‚àÄ x g, is_ultrafilter g ‚Üí g ‚â§ ùìù x ‚Üí g.map f ‚â§ ùìù (f x) :=
by simp only [continuous_iff_continuous_at, continuous_at_iff_ultrafilter]

/-- A piecewise defined function `if p then f else g` is continuous, if both `f` and `g`
are continuous, and they coincide on the frontier (boundary) of the set `{a | p a}`. -/
lemma continuous_if {p : Œ± ‚Üí Prop} {f g : Œ± ‚Üí Œ≤} {h : ‚àÄa, decidable (p a)}
  (hp : ‚àÄa‚ààfrontier {a | p a}, f a = g a) (hf : continuous f) (hg : continuous g) :
  continuous (Œªa, @ite (p a) (h a) Œ≤ (f a) (g a)) :=
continuous_iff_is_closed.mpr $
assume s hs,
have (Œªa, ite (p a) (f a) (g a)) ‚Åª¬π' s =
    (closure {a | p a} ‚à©  f ‚Åª¬π' s) ‚à™ (closure {a | ¬¨ p a} ‚à© g ‚Åª¬π' s),
  from set.ext $ assume a,
  classical.by_cases
    (assume : a ‚àà frontier {a | p a},
      have hac : a ‚àà closure {a | p a}, from this.left,
      have hai : a ‚àà closure {a | ¬¨ p a},
        from have a ‚àà (interior {a | p a})·∂ú, from this.right, by rwa [‚Üêclosure_compl] at this,
      by by_cases p a; simp [h, hp a this, hac, hai, iff_def] {contextual := tt})
    (assume hf : a ‚àà (frontier {a | p a})·∂ú,
      classical.by_cases
        (assume : p a,
          have hc : a ‚àà closure {a | p a}, from subset_closure this,
          have hnc : a ‚àâ closure {a | ¬¨ p a},
            by show a ‚àâ closure {a | p a}·∂ú; rw [closure_compl]; simpa [frontier, hc] using hf,
          by simp [this, hc, hnc])
        (assume : ¬¨ p a,
          have hc : a ‚àà closure {a | ¬¨ p a}, from subset_closure this,
          have hnc : a ‚àâ closure {a | p a},
            begin
              have hc : a ‚àà closure {a | p a}·∂ú, from hc,
              simp [closure_compl] at hc,
              simpa [frontier, hc] using hf
            end,
          by simp [this, hc, hnc])),
by rw [this]; exact is_closed_union
  (is_closed_inter is_closed_closure $ continuous_iff_is_closed.mp hf s hs)
  (is_closed_inter is_closed_closure $ continuous_iff_is_closed.mp hg s hs)


/- Continuity and partial functions -/

/-- Continuity of a partial function -/
def pcontinuous (f : Œ± ‚Üí. Œ≤) := ‚àÄ s, is_open s ‚Üí is_open (f.preimage s)

lemma open_dom_of_pcontinuous {f : Œ± ‚Üí. Œ≤} (h : pcontinuous f) : is_open f.dom :=
by rw [‚Üêpfun.preimage_univ]; exact h _ is_open_univ

lemma pcontinuous_iff' {f : Œ± ‚Üí. Œ≤} :
  pcontinuous f ‚Üî ‚àÄ {x y} (h : y ‚àà f x), ptendsto' f (ùìù x) (ùìù y) :=
begin
  split,
  { intros h x y h',
    simp only [ptendsto'_def, mem_nhds_sets_iff],
    rintros s ‚ü®t, tsubs, opent, yt‚ü©,
    exact ‚ü®f.preimage t, pfun.preimage_mono _ tsubs, h _ opent, ‚ü®y, yt, h'‚ü©‚ü©
  },
  intros hf s os,
  rw is_open_iff_nhds,
  rintros x ‚ü®y, ys, fxy‚ü© t,
  rw [mem_principal_sets],
  assume h : f.preimage s ‚äÜ t,
  change t ‚àà ùìù x,
  apply mem_sets_of_superset _ h,
  have h' : ‚àÄ s ‚àà ùìù y, f.preimage s ‚àà ùìù x,
  { intros s hs,
     have : ptendsto' f (ùìù x) (ùìù y) := hf fxy,
     rw ptendsto'_def at this,
     exact this s hs },
  show f.preimage s ‚àà ùìù x,
  apply h', rw mem_nhds_sets_iff, exact ‚ü®s, set.subset.refl _, os, ys‚ü©
end

lemma image_closure_subset_closure_image {f : Œ± ‚Üí Œ≤} {s : set Œ±} (h : continuous f) :
  f '' closure s ‚äÜ closure (f '' s) :=
have ‚àÄ (a : Œ±), cluster_pt a (ùìü s) ‚Üí cluster_pt (f a) (ùìü (f '' s)),
  from assume a ha,
  have h‚ÇÅ : ¬¨ map f (ùìù a ‚äì ùìü s) = ‚ä•,
    by rwa[map_eq_bot_iff],
  have h‚ÇÇ : map f (ùìù a ‚äì ùìü s) ‚â§ ùìù (f a) ‚äì ùìü (f '' s),
    from le_inf
      (le_trans (map_mono inf_le_left) $ by rw [continuous_iff_continuous_at] at h; exact h a)
      (le_trans (map_mono inf_le_right) $ by simp [subset_preimage_image] ),
  ne_bot_of_le_ne_bot h‚ÇÅ h‚ÇÇ,
by simp [image_subset_iff, closure_eq_cluster_pts]; assumption

lemma mem_closure {s : set Œ±} {t : set Œ≤} {f : Œ± ‚Üí Œ≤} {a : Œ±}
  (hf : continuous f) (ha : a ‚àà closure s) (ht : ‚àÄa‚ààs, f a ‚àà t) : f a ‚àà closure t :=
subset.trans (image_closure_subset_closure_image hf) (closure_mono $ image_subset_iff.2 ht) $
  (mem_image_of_mem f ha)

/-!
### Function with dense range
-/

section dense_range
variables {Œ∫ Œπ : Type*} (f : Œ∫ ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥)

/-- `f : Œπ ‚Üí Œ≤` has dense range if its range (image) is a dense subset of Œ≤. -/
def dense_range := dense (range f)

variables {f}

/-- A surjective map has dense range. -/
lemma function.surjective.dense_range (hf : function.surjective f) : dense_range f :=
Œª x, by simp [hf.range_eq]

lemma dense_range_iff_closure_range : dense_range f ‚Üî closure (range f) = univ :=
dense_iff_closure_eq

lemma dense_range.closure_range (h : dense_range f) : closure (range f) = univ :=
h.closure_eq

lemma continuous.range_subset_closure_image_dense {f : Œ± ‚Üí Œ≤} (hf : continuous f)
  {s : set Œ±} (hs : dense s) :
  range f ‚äÜ closure (f '' s) :=
by { rw [‚Üê image_univ, ‚Üê hs.closure_eq], exact image_closure_subset_closure_image hf }

/-- The image of a dense set under a continuous map with dense range is a dense set. -/
lemma dense_range.dense_image {f : Œ± ‚Üí Œ≤} (hf' : dense_range f) (hf : continuous f)
  {s : set Œ±} (hs : dense s) :
  dense (f '' s)  :=
(hf'.mono $ hf.range_subset_closure_image_dense hs).of_closure

/-- If a continuous map with dense range maps a dense set to a subset of `t`, then `t` is a dense
set. -/
lemma dense_range.dense_of_maps_to {f : Œ± ‚Üí Œ≤} (hf' : dense_range f) (hf : continuous f)
  {s : set Œ±} (hs : dense s) {t : set Œ≤} (ht : maps_to f s t) :
  dense t :=
(hf'.dense_image hf hs).mono ht.image_subset

/-- Composition of a continuous map with dense range and a function with dense range has dense
range. -/
lemma dense_range.comp {g : Œ≤ ‚Üí Œ≥} {f : Œ∫ ‚Üí Œ≤} (hg : dense_range g) (hf : dense_range f)
  (cg : continuous g) :
  dense_range (g ‚àò f) :=
by { rw [dense_range, range_comp], exact hg.dense_image cg hf }

lemma dense_range.nonempty_iff (hf : dense_range f) : nonempty Œ∫ ‚Üî nonempty Œ≤ :=
range_nonempty_iff_nonempty.symm.trans hf.nonempty_iff

lemma dense_range.nonempty [h : nonempty Œ≤] (hf : dense_range f) : nonempty Œ∫ :=
hf.nonempty_iff.mpr h

/-- Given a function `f : Œ± ‚Üí Œ≤` with dense range and `b : Œ≤`, returns some `a : Œ±`. -/
def dense_range.some (hf : dense_range f) (b : Œ≤) : Œ∫ :=
classical.choice $ hf.nonempty_iff.mpr ‚ü®b‚ü©

end dense_range

end continuous
