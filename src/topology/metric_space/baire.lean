/-
Copyright (c) 2019 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel
-/
import analysis.specific_limits
import order.filter.countable_Inter

/-!
# Baire theorem

In a complete metric space, a countable intersection of dense open subsets is dense.

The good concept underlying the theorem is that of a GŒ¥ set, i.e., a countable intersection
of open sets. Then Baire theorem can also be formulated as the fact that a countable
intersection of dense GŒ¥ sets is a dense GŒ¥ set. We prove Baire theorem, giving several different
formulations that can be handy. We also prove the important consequence that, if the space is
covered by a countable union of closed sets, then the union of their interiors is dense.

The names of the theorems do not contain the string "Baire", but are instead built from the form of
the statement. "Baire" is however in the docstring of all the theorems, to facilitate grep searches.

We also define the filter `residual Œ±` generated by dense `GŒ¥` sets and prove that this filter
has the countable intersection property.
-/

noncomputable theory
open_locale classical topological_space filter

open filter encodable set

variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {Œπ : Type*}

section is_GŒ¥
variable [topological_space Œ±]

/-- A GŒ¥ set is a countable intersection of open sets. -/
def is_GŒ¥ (s : set Œ±) : Prop :=
  ‚àÉT : set (set Œ±), (‚àÄt ‚àà T, is_open t) ‚àß countable T ‚àß s = (‚ãÇ‚ÇÄ T)

/-- An open set is a GŒ¥ set. -/
lemma is_open.is_GŒ¥ {s : set Œ±} (h : is_open s) : is_GŒ¥ s :=
‚ü®{s}, by simp [h], countable_singleton _, (set.sInter_singleton _).symm‚ü©

lemma is_GŒ¥_univ : is_GŒ¥ (univ : set Œ±) := is_open_univ.is_GŒ¥

lemma is_GŒ¥_bInter_of_open {I : set Œπ} (hI : countable I) {f : Œπ ‚Üí set Œ±}
  (hf : ‚àÄi ‚àà I, is_open (f i)) : is_GŒ¥ (‚ãÇi‚ààI, f i) :=
‚ü®f '' I, by rwa ball_image_iff, hI.image _, by rw sInter_image‚ü©

lemma is_GŒ¥_Inter_of_open [encodable Œπ] {f : Œπ ‚Üí set Œ±}
  (hf : ‚àÄi, is_open (f i)) : is_GŒ¥ (‚ãÇi, f i) :=
‚ü®range f, by rwa forall_range_iff, countable_range _, by rw sInter_range‚ü©

/-- A countable intersection of GŒ¥ sets is a GŒ¥ set. -/
lemma is_GŒ¥_sInter {S : set (set Œ±)} (h : ‚àÄs‚ààS, is_GŒ¥ s) (hS : countable S) : is_GŒ¥ (‚ãÇ‚ÇÄ S) :=
begin
  choose T hT using h,
  refine ‚ü®_, _, _, (sInter_bUnion (Œª s hs, (hT s hs).2.2)).symm‚ü©,
  { simp only [mem_Union],
    rintros t ‚ü®s, hs, tTs‚ü©,
    exact (hT s hs).1 t tTs },
  { exact hS.bUnion (Œªs hs, (hT s hs).2.1) },
end

lemma is_GŒ¥_Inter [encodable Œπ]  {s : Œπ ‚Üí set Œ±} (hs : ‚àÄ i, is_GŒ¥ (s i)) : is_GŒ¥ (‚ãÇ i, s i) :=
is_GŒ¥_sInter (forall_range_iff.2 hs) $ countable_range s

lemma is_GŒ¥_bInter {s : set Œπ} (hs : countable s) {t : Œ† i ‚àà s, set Œ±} (ht : ‚àÄ i ‚àà s, is_GŒ¥ (t i ‚Äπ_‚Ä∫)) :
  is_GŒ¥ (‚ãÇ i ‚àà s, t i ‚Äπ_‚Ä∫) :=
begin
  rw [bInter_eq_Inter],
  haveI := hs.to_encodable,
  exact is_GŒ¥_Inter (Œª x, ht x x.2)
end

lemma is_GŒ¥.inter {s t : set Œ±} (hs : is_GŒ¥ s) (ht : is_GŒ¥ t) : is_GŒ¥ (s ‚à© t) :=
by { rw inter_eq_Inter, exact is_GŒ¥_Inter (bool.forall_bool.2 ‚ü®ht, hs‚ü©) }

/-- The union of two GŒ¥ sets is a GŒ¥ set. -/
lemma is_GŒ¥.union {s t : set Œ±} (hs : is_GŒ¥ s) (ht : is_GŒ¥ t) : is_GŒ¥ (s ‚à™ t) :=
begin
  rcases hs with ‚ü®S, Sopen, Scount, rfl‚ü©,
  rcases ht with ‚ü®T, Topen, Tcount, rfl‚ü©,
  rw [sInter_union_sInter],
  apply is_GŒ¥_bInter_of_open (countable_prod Scount Tcount),
  rintros ‚ü®a, b‚ü© hab,
  exact is_open_union (Sopen a hab.1) (Topen b hab.2)
end

end is_GŒ¥

/-- A set `s` is called *residual* if it includes a dense `GŒ¥` set. If `Œ±` is a Baire space
(e.g., a complete metric space), then residual sets form a filter, see `mem_residual`.

 For technical reasons we define the filter `residual` in any topological space
 but in a non-Baire space it is not useful because it may contain some non-residual
 sets. -/
def residual (Œ± : Type*) [topological_space Œ±] : filter Œ± :=
‚®Ö t (ht : is_GŒ¥ t) (ht' : dense t), ùìü t

section Baire_theorem
open emetric ennreal
variables [emetric_space Œ±] [complete_space Œ±]

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here when
the source space is ‚Ñï (and subsumed below by `dense_Inter_of_open` working with any
encodable source space). -/
theorem dense_Inter_of_open_nat {f : ‚Ñï ‚Üí set Œ±} (ho : ‚àÄn, is_open (f n))
  (hd : ‚àÄn, dense (f n)) : dense (‚ãÇn, f n) :=
begin
  let B : ‚Ñï ‚Üí ennreal := Œªn, 1/2^n,
  have Bpos : ‚àÄn, 0 < B n,
  { intro n,
    simp only [B, div_def, one_mul, ennreal.inv_pos],
    exact pow_ne_top two_ne_top },
  /- Translate the density assumption into two functions `center` and `radius` associating
  to any n, x, Œ¥, Œ¥pos a center and a positive radius such that
  `closed_ball center radius` is included both in `f n` and in `closed_ball x Œ¥`.
  We can also require `radius ‚â§ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/
  have : ‚àÄn x Œ¥, Œ¥ > 0 ‚Üí ‚àÉy r, r > 0 ‚àß r ‚â§ B (n+1) ‚àß closed_ball y r ‚äÜ (closed_ball x Œ¥) ‚à© f n,
  { assume n x Œ¥ Œ¥pos,
    have : x ‚àà closure (f n) := hd n x,
    rcases emetric.mem_closure_iff.1 this (Œ¥/2) (ennreal.half_pos Œ¥pos) with ‚ü®y, ys, xy‚ü©,
    rw edist_comm at xy,
    obtain ‚ü®r, rpos, hr‚ü© : ‚àÉ r > 0, closed_ball y r ‚äÜ f n :=
      nhds_basis_closed_eball.mem_iff.1 (is_open_iff_mem_nhds.1 (ho n) y ys),
    refine ‚ü®y, min (min (Œ¥/2) r) (B (n+1)), _, _, Œªz hz, ‚ü®_, _‚ü©‚ü©,
    show 0 < min (min (Œ¥ / 2) r) (B (n+1)),
      from lt_min (lt_min (ennreal.half_pos Œ¥pos) rpos) (Bpos (n+1)),
    show min (min (Œ¥ / 2) r) (B (n+1)) ‚â§ B (n+1), from min_le_right _ _,
    show z ‚àà closed_ball x Œ¥, from calc
      edist z x ‚â§ edist z y + edist y x : edist_triangle _ _ _
      ... ‚â§ (min (min (Œ¥ / 2) r) (B (n+1))) + (Œ¥/2) : add_le_add hz (le_of_lt xy)
      ... ‚â§ Œ¥/2 + Œ¥/2 : add_le_add (le_trans (min_le_left _ _) (min_le_left _ _)) (le_refl _)
      ... = Œ¥ : ennreal.add_halves Œ¥,
    show z ‚àà f n, from hr (calc
      edist z y ‚â§ min (min (Œ¥ / 2) r) (B (n+1)) : hz
      ... ‚â§ r : le_trans (min_le_left _ _) (min_le_right _ _)) },
  choose! center radius H using this,
  refine Œª x, (mem_closure_iff_nhds_basis nhds_basis_closed_eball).2 (Œª Œµ Œµpos, _),
  /- `Œµ` is positive. We have to find a point in the ball of radius `Œµ` around `x` belonging to all
  `f n`. For this, we construct inductively a sequence `F n = (c n, r n)` such that the closed ball
  `closed_ball (c n) (r n)` is included in the previous ball and in `f n`, and such that
  `r n` is small enough to ensure that `c n` is a Cauchy sequence. Then `c n` converges to a
  limit which belongs to all the `f n`. -/
  let F : ‚Ñï ‚Üí (Œ± √ó ennreal) := Œªn, nat.rec_on n (prod.mk x (min Œµ (B 0)))
                              (Œªn p, prod.mk (center n p.1 p.2) (radius n p.1 p.2)),
  let c : ‚Ñï ‚Üí Œ± := Œªn, (F n).1,
  let r : ‚Ñï ‚Üí ennreal := Œªn, (F n).2,
  have rpos : ‚àÄn, r n > 0,
  { assume n,
    induction n with n hn,
    exact lt_min Œµpos (Bpos 0),
    exact (H n (c n) (r n) hn).1 },
  have rB : ‚àÄn, r n ‚â§ B n,
  { assume n,
    induction n with n hn,
    exact min_le_right _ _,
    exact (H n (c n) (r n) (rpos n)).2.1 },
  have incl : ‚àÄn, closed_ball (c (n+1)) (r (n+1)) ‚äÜ (closed_ball (c n) (r n)) ‚à© (f n) :=
    Œªn, (H n (c n) (r n) (rpos n)).2.2,
  have cdist : ‚àÄn, edist (c n) (c (n+1)) ‚â§ B n,
  { assume n,
    rw edist_comm,
    have A : c (n+1) ‚àà closed_ball (c (n+1)) (r (n+1)) := mem_closed_ball_self,
    have I := calc
      closed_ball (c (n+1)) (r (n+1)) ‚äÜ closed_ball (c n) (r n) :
        subset.trans (incl n) (inter_subset_left _ _)
      ... ‚äÜ closed_ball (c n) (B n) : closed_ball_subset_closed_ball (rB n),
    exact I A },
  have : cauchy_seq c :=
    cauchy_seq_of_edist_le_geometric_two _ one_ne_top cdist,
  -- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.
  rcases cauchy_seq_tendsto_of_complete this with ‚ü®y, ylim‚ü©,
  -- this point `y` will be the desired point. We will check that it belongs to all
  -- `f n` and to `ball x Œµ`.
  use y,
  simp only [exists_prop, set.mem_Inter],
  have I : ‚àÄn, ‚àÄm ‚â• n, closed_ball (c m) (r m) ‚äÜ closed_ball (c n) (r n),
  { assume n,
    refine nat.le_induction _ (Œªm hnm h, _),
    { exact subset.refl _ },
    { exact subset.trans (incl m) (subset.trans (inter_subset_left _ _) h) }},
  have yball : ‚àÄn, y ‚àà closed_ball (c n) (r n),
  { assume n,
    refine is_closed_ball.mem_of_tendsto ylim _,
    refine (filter.eventually_ge_at_top n).mono (Œª m hm, _),
    exact I n m hm mem_closed_ball_self },
  split,
  show ‚àÄn, y ‚àà f n,
  { assume n,
    have : closed_ball (c (n+1)) (r (n+1)) ‚äÜ f n := subset.trans (incl n) (inter_subset_right _ _),
    exact this (yball (n+1)) },
  show edist y x ‚â§ Œµ, from le_trans (yball 0) (min_le_left _ _),
end

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ‚ãÇ‚ÇÄ. -/
theorem dense_sInter_of_open {S : set (set Œ±)} (ho : ‚àÄs‚ààS, is_open s) (hS : countable S)
  (hd : ‚àÄs‚ààS, dense s) : dense (‚ãÇ‚ÇÄS) :=
begin
  cases S.eq_empty_or_nonempty with h h,
  { simp [h] },
  { rcases hS.exists_surjective h with ‚ü®f, hf‚ü©,
    have F : ‚àÄn, f n ‚àà S := Œªn, by rw hf; exact mem_range_self _,
    rw [hf, sInter_range],
    exact dense_Inter_of_open_nat (Œªn, ho _ (F n)) (Œªn, hd _ (F n)) }
end

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_open {S : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (ho : ‚àÄs‚ààS, is_open (f s))
  (hS : countable S) (hd : ‚àÄs‚ààS, dense (f s)) : dense (‚ãÇs‚ààS, f s) :=
begin
  rw ‚Üê sInter_image,
  apply dense_sInter_of_open,
  { rwa ball_image_iff },
  { exact hS.image _ },
  { rwa ball_image_iff }
end

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_open [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±} (ho : ‚àÄs, is_open (f s))
  (hd : ‚àÄs, dense (f s)) : dense (‚ãÇs, f s) :=
begin
  rw ‚Üê sInter_range,
  apply dense_sInter_of_open,
  { rwa forall_range_iff },
  { exact countable_range _ },
  { rwa forall_range_iff }
end

/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with ‚ãÇ‚ÇÄ. -/
theorem dense_sInter_of_GŒ¥ {S : set (set Œ±)} (ho : ‚àÄs‚ààS, is_GŒ¥ s) (hS : countable S)
  (hd : ‚àÄs‚ààS, dense s) : dense (‚ãÇ‚ÇÄS) :=
begin
  -- the result follows from the result for a countable intersection of dense open sets,
  -- by rewriting each set as a countable intersection of open sets, which are of course dense.
  choose T hT using ho,
  have : ‚ãÇ‚ÇÄ S = ‚ãÇ‚ÇÄ (‚ãÉs‚ààS, T s ‚Äπ_‚Ä∫) := (sInter_bUnion (Œªs hs, (hT s hs).2.2)).symm,
  rw this,
  refine dense_sInter_of_open _ (hS.bUnion (Œªs hs, (hT s hs).2.1)) _;
    simp only [set.mem_Union, exists_prop]; rintro t ‚ü®s, hs, tTs‚ü©,
  show is_open t,
  { exact (hT s hs).1 t tTs },
  show dense t,
  { intro x,
    have := hd s hs x,
    rw (hT s hs).2.2 at this,
    exact closure_mono (sInter_subset_of_mem tTs) this }
end

/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_GŒ¥ [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±} (ho : ‚àÄs, is_GŒ¥ (f s))
  (hd : ‚àÄs, dense (f s)) : dense (‚ãÇs, f s) :=
begin
  rw ‚Üê sInter_range,
  exact dense_sInter_of_GŒ¥ (forall_range_iff.2 ‚Äπ_‚Ä∫) (countable_range _) (forall_range_iff.2 ‚Äπ_‚Ä∫)
end

/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_GŒ¥ {S : set Œ≤} {f : Œ† x ‚àà S, set Œ±} (ho : ‚àÄs‚ààS, is_GŒ¥ (f s ‚Äπ_‚Ä∫))
  (hS : countable S) (hd : ‚àÄs‚ààS, dense (f s ‚Äπ_‚Ä∫)) : dense (‚ãÇs‚ààS, f s ‚Äπ_‚Ä∫) :=
begin
  rw bInter_eq_Inter,
  haveI := hS.to_encodable,
  exact dense_Inter_of_GŒ¥ (Œª s, ho s s.2) (Œª s, hd s s.2)
end

/-- Baire theorem: the intersection of two dense GŒ¥ sets is dense. -/
theorem dense.inter_of_GŒ¥ {s t : set Œ±} (hs : is_GŒ¥ s) (ht : is_GŒ¥ t) (hsc : dense s)
  (htc : dense t) :
  dense (s ‚à© t) :=
begin
  rw [inter_eq_Inter],
  apply dense_Inter_of_GŒ¥; simp [bool.forall_bool, *]
end

/-- A property holds on a residual (comeagre) set if and only if it holds on some dense `GŒ¥` set. -/
lemma eventually_residual {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂† x in residual Œ±, p x) ‚Üî ‚àÉ (t : set Œ±), is_GŒ¥ t ‚àß dense t ‚àß ‚àÄ x ‚àà t, p x :=
calc (‚àÄ·∂† x in residual Œ±, p x) ‚Üî
  ‚àÄ·∂† x in ‚®Ö (t : set Œ±) (ht : is_GŒ¥ t ‚àß dense t), ùìü t, p x :
    by simp only [residual, infi_and]
... ‚Üî ‚àÉ (t : set Œ±) (ht : is_GŒ¥ t ‚àß dense t), ‚àÄ·∂† x in ùìü t, p x :
  mem_binfi (Œª t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ, ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, ‚ü®h‚ÇÅ.1.inter h‚ÇÇ.1, dense.inter_of_GŒ¥ h‚ÇÅ.1 h‚ÇÇ.1 h‚ÇÅ.2 h‚ÇÇ.2‚ü©,
    by simp‚ü©) ‚ü®univ, is_GŒ¥_univ, dense_univ‚ü©
... ‚Üî _ : by simp [and_assoc]

/-- A set is residual (comeagre) if and only if it includes a dense `GŒ¥` set. -/
lemma mem_residual {s : set Œ±} : s ‚àà residual Œ± ‚Üî ‚àÉ t ‚äÜ s, is_GŒ¥ t ‚àß dense t :=
(@eventually_residual Œ± _ _ (Œª x, x ‚àà s)).trans $ exists_congr $
Œª t, by rw [exists_prop, and_comm (t ‚äÜ s), subset_def, and_assoc]

instance : countable_Inter_filter (residual Œ±) :=
‚ü®begin
  intros S hSc hS,
  simp only [mem_residual] at *,
  choose T hTs hT using hS,
  refine ‚ü®‚ãÇ s ‚àà S, T s ‚Äπ_‚Ä∫, _, _, _‚ü©,
  { rw [sInter_eq_bInter],
    exact Inter_subset_Inter (Œª s, Inter_subset_Inter $ hTs s) },
  { exact is_GŒ¥_bInter hSc (Œª s hs, (hT s hs).1) },
  { exact dense_bInter_of_GŒ¥ (Œª s hs, (hT s hs).1) hSc (Œª s hs, (hT s hs).2) }
end‚ü©

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is a countable set in any type. -/
theorem dense_bUnion_interior_of_closed {S : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (hc : ‚àÄs‚ààS, is_closed (f s))
  (hS : countable S) (hU : (‚ãÉs‚ààS, f s) = univ) : dense (‚ãÉs‚ààS, interior (f s)) :=
begin
  let g := Œªs, (frontier (f s))·∂ú,
  have : dense (‚ãÇs‚ààS, g s),
  { refine dense_bInter_of_open (Œªs hs, _) hS (Œªs hs, _),
    show is_open (g s), from is_open_compl_iff.2 is_closed_frontier,
    show dense (g s),
    { intro x,
      simp [interior_frontier (hc s hs)] }},
  refine this.mono _,
  show (‚ãÇs‚ààS, g s) ‚äÜ (‚ãÉs‚ààS, interior (f s)),
  assume x hx,
  have : x ‚àà ‚ãÉs‚ààS, f s, { have := mem_univ x, rwa ‚Üê hU at this },
  rcases mem_bUnion_iff.1 this with ‚ü®s, hs, xs‚ü©,
  have : x ‚àà g s := mem_bInter_iff.1 hx s hs,
  have : x ‚àà interior (f s),
  { have : x ‚àà f s \ (frontier (f s)) := mem_inter xs this,
    simpa [frontier, xs, (hc s hs).closure_eq] using this },
  exact mem_bUnion_iff.2 ‚ü®s, ‚ü®hs, this‚ü©‚ü©
end

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with `‚ãÉ‚ÇÄ`. -/
theorem dense_sUnion_interior_of_closed {S : set (set Œ±)} (hc : ‚àÄs‚ààS, is_closed s)
  (hS : countable S) (hU : (‚ãÉ‚ÇÄ S) = univ) : dense (‚ãÉs‚ààS, interior s) :=
by rw sUnion_eq_bUnion at hU; exact dense_bUnion_interior_of_closed hc hS hU

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is an encodable type. -/
theorem dense_Union_interior_of_closed [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±} (hc : ‚àÄs, is_closed (f s))
  (hU : (‚ãÉs, f s) = univ) : dense (‚ãÉs, interior (f s)) :=
begin
  rw ‚Üê bUnion_univ,
  apply dense_bUnion_interior_of_closed,
  { simp [hc] },
  { apply countable_encodable },
  { rwa ‚Üê bUnion_univ at hU }
end

/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets
covers the space, then one of the sets has nonempty interior. -/
theorem nonempty_interior_of_Union_of_closed [nonempty Œ±] [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±}
  (hc : ‚àÄs, is_closed (f s)) (hU : (‚ãÉs, f s) = univ) :
  ‚àÉs, (interior $ f s).nonempty :=
begin
  by_contradiction h,
  simp only [not_exists, not_nonempty_iff_eq_empty] at h,
  have := calc ‚àÖ = closure (‚ãÉs, interior (f s)) : by simp [h]
             ... = univ : (dense_Union_interior_of_closed hc hU).closure_eq,
  exact univ_nonempty.ne_empty this.symm
end

end Baire_theorem
