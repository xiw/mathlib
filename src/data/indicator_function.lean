/-
Copyright (c) 2020 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou
-/
import algebra.group.pi
import group_theory.group_action
import data.support
import data.finset.lattice

/-!
# Indicator function

`indicator (s : set Œ±) (f : Œ± ‚Üí Œ≤) (a : Œ±)` is `f a` if `a ‚àà s` and is `0` otherwise.

## Implementation note

In mathematics, an indicator function or a characteristic function is a function used to indicate
membership of an element in a set `s`, having the value `1` for all elements of `s` and the value `0`
otherwise. But since it is usually used to restrict a function to a certain set `s`, we let the
indicator function take the value `f x` for some function `f`, instead of `1`. If the usual indicator
function is needed, just set `f` to be the constant function `Œªx, 1`.

## Tags
indicator, characteristic
-/

noncomputable theory
open_locale classical big_operators
open function

variables {Œ± Œ±' Œ≤ Œ≥ : Type*}

namespace set

section has_zero
variables [has_zero Œ≤] {s t : set Œ±} {f g : Œ± ‚Üí Œ≤} {a : Œ±}

/-- `indicator s f a` is `f a` if `a ‚àà s`, `0` otherwise.  -/
@[reducible]
def indicator (s : set Œ±) (f : Œ± ‚Üí Œ≤) : Œ± ‚Üí Œ≤ := Œª x, if x ‚àà s then f x else 0

@[simp] lemma piecewise_eq_indicator {s : set Œ±} : s.piecewise f 0 = s.indicator f := rfl

lemma indicator_apply (s : set Œ±) (f : Œ± ‚Üí Œ≤) (a : Œ±) :
  indicator s f a = if a ‚àà s then f a else 0 := rfl

@[simp] lemma indicator_of_mem (h : a ‚àà s) (f : Œ± ‚Üí Œ≤) : indicator s f a = f a := if_pos h

@[simp] lemma indicator_of_not_mem (h : a ‚àâ s) (f : Œ± ‚Üí Œ≤) : indicator s f a = 0 := if_neg h

/-- If an indicator function is nonzero at a point, that
point is in the set. -/
lemma mem_of_indicator_ne_zero (h : indicator s f a ‚â† 0) : a ‚àà s :=
not_imp_comm.1 (Œª hn, indicator_of_not_mem hn f) h

lemma eq_on_indicator : eq_on (indicator s f) f s := Œª x hx, indicator_of_mem hx f

lemma support_indicator : function.support (s.indicator f) ‚äÜ s :=
Œª x hx, hx.imp_symm (Œª h, indicator_of_not_mem h f)

lemma indicator_of_support_subset (h : support f ‚äÜ s) : s.indicator f = f :=
begin
  ext x,
  by_cases hx : f x = 0,
  { rw hx,
    by_contradiction H,
    have := mem_of_indicator_ne_zero H,
    rw [indicator_of_mem this f, hx] at H,
    exact H rfl },
  { exact indicator_of_mem (h hx) f }
end

@[simp] lemma indicator_support : (support f).indicator f = f :=
indicator_of_support_subset $ subset.refl _

@[simp] lemma indicator_range_comp {Œπ : Sort*} (f : Œπ ‚Üí Œ±) (g : Œ± ‚Üí Œ≤) :
  indicator (range f) g ‚àò f = g ‚àò f :=
piecewise_range_comp _ _ _

lemma indicator_congr (h : ‚àÄ a ‚àà s, f a = g a) : indicator s f = indicator s g :=
funext $ Œªx, by { simp only [indicator], split_ifs, { exact h _ h_1 }, refl }

@[simp] lemma indicator_univ (f : Œ± ‚Üí Œ≤) : indicator (univ : set Œ±) f = f :=
funext $ Œªx, indicator_of_mem (mem_univ _) f

@[simp] lemma indicator_empty (f : Œ± ‚Üí Œ≤) : indicator (‚àÖ : set Œ±) f = Œªa, 0 :=
funext $ Œªx, indicator_of_not_mem (not_mem_empty _) f

variable (Œ≤)

@[simp] lemma indicator_zero (s : set Œ±) : indicator s (Œªx, (0:Œ≤)) = Œªx, (0:Œ≤) :=
funext $ Œªx, by { simp only [indicator], split_ifs, refl, refl }

@[simp] lemma indicator_zero' {s : set Œ±} : s.indicator (0 : Œ± ‚Üí Œ≤) = 0 :=
indicator_zero Œ≤ s

variable {Œ≤}

lemma indicator_indicator (s t : set Œ±) (f : Œ± ‚Üí Œ≤) : indicator s (indicator t f) = indicator (s ‚à© t) f :=
funext $ Œªx, by { simp only [indicator], split_ifs, repeat {simp * at * {contextual := tt}} }

lemma comp_indicator (h : Œ≤ ‚Üí Œ≥) (f : Œ± ‚Üí Œ≤) {s : set Œ±} {x : Œ±} :
  h (s.indicator f x) = s.piecewise (h ‚àò f) (const Œ± (h 0)) x :=
s.comp_piecewise h

lemma indicator_comp_right {s : set Œ±} (f : Œ≥ ‚Üí Œ±) {g : Œ± ‚Üí Œ≤} {x : Œ≥} :
  indicator (f ‚Åª¬π' s) (g ‚àò f) x = indicator s g (f x) :=
by { simp only [indicator], split_ifs; refl }

lemma indicator_comp_of_zero [has_zero Œ≥] {g : Œ≤ ‚Üí Œ≥} (hg : g 0 = 0) :
  indicator s (g ‚àò f) = g ‚àò (indicator s f) :=
begin
  funext,
  simp only [indicator],
  split_ifs; simp [*]
end

lemma indicator_preimage (s : set Œ±) (f : Œ± ‚Üí Œ≤) (B : set Œ≤) :
  (indicator s f)‚Åª¬π' B = s ‚à© f ‚Åª¬π' B ‚à™ s·∂ú ‚à© (Œªa:Œ±, (0:Œ≤)) ‚Åª¬π' B :=
piecewise_preimage s f 0 B

lemma indicator_preimage_of_not_mem (s : set Œ±) (f : Œ± ‚Üí Œ≤) {t : set Œ≤} (ht : (0:Œ≤) ‚àâ t) :
  (indicator s f)‚Åª¬π' t = s ‚à© f ‚Åª¬π' t :=
by simp [indicator_preimage, set.preimage_const_of_not_mem ht]

lemma mem_range_indicator {r : Œ≤} {s : set Œ±} {f : Œ± ‚Üí Œ≤} :
  r ‚àà range (indicator s f) ‚Üî (r = 0 ‚àß s ‚â† univ) ‚à® (r ‚àà f '' s) :=
by simp [indicator, ite_eq_iff, exists_or_distrib, eq_univ_iff_forall, and_comm, or_comm,
  @eq_comm _ r 0]

lemma indicator_rel_indicator {r : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (h0 : r 0 0) (ha : a ‚àà s ‚Üí r (f a) (g a)) :
  r (indicator s f a) (indicator s g a) :=
by { simp only [indicator], split_ifs with has has, exacts [ha has, h0] }

/-- Consider a sum of `g i (f i)` over a `finset`.  Suppose `g` is a
function such as multiplication, which maps a second argument of 0 to
0.  (A typical use case would be a weighted sum of `f i * h i` or `f i
‚Ä¢ h i`, where `f` gives the weights that are multiplied by some other
function `h`.)  Then if `f` is replaced by the corresponding indicator
function, the `finset` may be replaced by a possibly larger `finset`
without changing the value of the sum. -/
lemma sum_indicator_subset_of_eq_zero {Œ≥ : Type*} [add_comm_monoid Œ≥] (f : Œ± ‚Üí Œ≤)
    (g : Œ± ‚Üí Œ≤ ‚Üí Œ≥) {s‚ÇÅ s‚ÇÇ : finset Œ±} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) (hg : ‚àÄ a, g a 0 = 0) :
  ‚àë i in s‚ÇÅ, g i (f i) = ‚àë i in s‚ÇÇ, g i (indicator ‚Üës‚ÇÅ f i) :=
begin
  rw ‚Üêfinset.sum_subset h _,
  { apply finset.sum_congr rfl,
    intros i hi,
    congr,
    symmetry,
    exact indicator_of_mem hi _ },
  { refine Œª i hi hn, _,
    convert hg i,
    exact indicator_of_not_mem hn _ }
end

/-- Summing an indicator function over a possibly larger `finset` is
the same as summing the original function over the original
`finset`. -/
lemma sum_indicator_subset {Œ≥ : Type*} [add_comm_monoid Œ≥] (f : Œ± ‚Üí Œ≥) {s‚ÇÅ s‚ÇÇ : finset Œ±}
    (h : s‚ÇÅ ‚äÜ s‚ÇÇ) : ‚àë i in s‚ÇÅ, f i = ‚àë i in s‚ÇÇ, indicator ‚Üës‚ÇÅ f i :=
sum_indicator_subset_of_eq_zero _ (Œª a b, b) h (Œª _, rfl)

end has_zero

section add_monoid
variables [add_monoid Œ≤] {s t : set Œ±} {f g : Œ± ‚Üí Œ≤} {a : Œ±}

lemma indicator_union_of_not_mem_inter (h : a ‚àâ s ‚à© t) (f : Œ± ‚Üí Œ≤) :
  indicator (s ‚à™ t) f a = indicator s f a + indicator t f a :=
by { simp only [indicator], split_ifs, repeat {simp * at * {contextual := tt}} }

lemma indicator_union_of_disjoint (h : disjoint s t) (f : Œ± ‚Üí Œ≤) :
  indicator (s ‚à™ t) f = Œªa, indicator s f a + indicator t f a :=
funext $ Œªa, indicator_union_of_not_mem_inter
  (by { convert not_mem_empty a, have := disjoint.eq_bot h, assumption })
  _

lemma indicator_add (s : set Œ±) (f g : Œ± ‚Üí Œ≤) :
  indicator s (Œªa, f a + g a) = Œªa, indicator s f a + indicator s g a :=
by { funext, simp only [indicator], split_ifs, { refl }, rw add_zero }

@[simp] lemma indicator_compl_add_self_apply (s : set Œ±) (f : Œ± ‚Üí Œ≤) (a : Œ±) :
  indicator s·∂ú f a + indicator s f a = f a :=
classical.by_cases (Œª ha : a ‚àà s, by simp [ha]) (Œª ha, by simp [ha])

@[simp] lemma indicator_compl_add_self (s : set Œ±) (f : Œ± ‚Üí Œ≤) :
  indicator s·∂ú f + indicator s f = f :=
funext $ indicator_compl_add_self_apply s f

@[simp] lemma indicator_self_add_compl_apply (s : set Œ±) (f : Œ± ‚Üí Œ≤) (a : Œ±) :
  indicator s f a + indicator s·∂ú f a = f a :=
classical.by_cases (Œª ha : a ‚àà s, by simp [ha]) (Œª ha, by simp [ha])

@[simp] lemma indicator_self_add_compl (s : set Œ±) (f : Œ± ‚Üí Œ≤) :
  indicator s f + indicator s·∂ú f = f :=
funext $ indicator_self_add_compl_apply s f

variables (Œ≤)
instance is_add_monoid_hom.indicator (s : set Œ±) : is_add_monoid_hom (Œªf:Œ± ‚Üí Œ≤, indicator s f) :=
{ map_add := Œª _ _, indicator_add _ _ _,
  map_zero := indicator_zero _ _ }

variables {Œ≤} {ùïú : Type*} [monoid ùïú] [distrib_mul_action ùïú Œ≤]

lemma indicator_smul (s : set Œ±) (r : ùïú) (f : Œ± ‚Üí Œ≤) :
  indicator s (Œª (x : Œ±), r ‚Ä¢ f x) = Œª (x : Œ±), r ‚Ä¢ indicator s f x :=
by { simp only [indicator], funext, split_ifs, refl, exact (smul_zero r).symm }

lemma indicator_add_eq_left {f g : Œ± ‚Üí Œ≤} (h : univ ‚äÜ f ‚Åª¬π' {0} ‚à™ g ‚Åª¬π' {0}) :
  (f ‚Åª¬π' {0})·∂ú.indicator (f + g) = f :=
begin
  ext x, by_cases hx : x ‚àà (f ‚Åª¬π' {0})·∂ú,
  { have : g x = 0, { simp at hx, specialize h (mem_univ x), simpa [hx] using h },
    simp [hx, this] },
  { simp * at * }
end

lemma indicator_add_eq_right {f g : Œ± ‚Üí Œ≤} (h : univ ‚äÜ f ‚Åª¬π' {0} ‚à™ g ‚Åª¬π' {0}) :
  (g ‚Åª¬π' {0})·∂ú.indicator (f + g) = g :=
begin
  ext x, by_cases hx : x ‚àà (g ‚Åª¬π' {0})·∂ú,
  { have : f x = 0, { simp at hx, specialize h (mem_univ x), simpa [hx] using h },
    simp [hx, this] },
  { simp * at * }
end

end add_monoid

section add_group
variables [add_group Œ≤] {s t : set Œ±} {f g : Œ± ‚Üí Œ≤} {a : Œ±}

variables (Œ≤)
instance is_add_group_hom.indicator (s : set Œ±) : is_add_group_hom (Œªf:Œ± ‚Üí Œ≤, indicator s f) :=
{ .. is_add_monoid_hom.indicator Œ≤ s }
variables {Œ≤}

lemma indicator_neg (s : set Œ±) (f : Œ± ‚Üí Œ≤) : indicator s (Œªa, - f a) = Œªa, - indicator s f a :=
show indicator s (- f) = - indicator s f, from is_add_group_hom.map_neg _ _

lemma indicator_sub (s : set Œ±) (f g : Œ± ‚Üí Œ≤) :
  indicator s (Œªa, f a - g a) = Œªa, indicator s f a - indicator s g a :=
show indicator s (f - g) = indicator s f - indicator s g, from is_add_group_hom.map_sub _ _ _

lemma indicator_compl (s : set Œ±) (f : Œ± ‚Üí Œ≤) : indicator s·∂ú f = f - indicator s f :=
eq_sub_of_add_eq $ s.indicator_compl_add_self f

lemma indicator_finset_sum {Œ≤} [add_comm_monoid Œ≤] {Œπ : Type*} (I : finset Œπ) (s : set Œ±) (f : Œπ ‚Üí Œ± ‚Üí Œ≤) :
  indicator s (‚àë i in I, f i) = ‚àë i in I, indicator s (f i) :=
begin
  convert (finset.sum_hom _ _).symm,
  split,
  exact indicator_zero _ _
end

lemma indicator_finset_bUnion {Œ≤} [add_comm_monoid Œ≤] {Œπ} (I : finset Œπ)
  (s : Œπ ‚Üí set Œ±) {f : Œ± ‚Üí Œ≤} : (‚àÄ (i ‚àà I) (j ‚àà I), i ‚â† j ‚Üí s i ‚à© s j = ‚àÖ) ‚Üí
  indicator (‚ãÉ i ‚àà I, s i) f = Œª a, ‚àë i in I, indicator (s i) f a :=
begin
  refine finset.induction_on I _ _,
  assume h,
  { funext, simp },
  assume a I haI ih hI,
  funext,
  simp only [haI, finset.sum_insert, not_false_iff],
  rw [finset.bUnion_insert, indicator_union_of_not_mem_inter, ih _],
  { assume i hi j hj hij,
    exact hI i (finset.mem_insert_of_mem hi) j (finset.mem_insert_of_mem hj) hij },
  simp only [not_exists, exists_prop, mem_Union, mem_inter_eq, not_and],
  assume hx a' ha',
  have := hI a (finset.mem_insert_self _ _) a' (finset.mem_insert_of_mem ha') _,
  { assume h, have h := mem_inter hx h, rw this at h, exact not_mem_empty _ h },
  { assume h, rw h at haI, contradiction }
end

end add_group

section mul_zero_class
variables [mul_zero_class Œ≤] {s t : set Œ±} {f g : Œ± ‚Üí Œ≤} {a : Œ±}

lemma indicator_mul (s : set Œ±) (f g : Œ± ‚Üí Œ≤) :
  indicator s (Œªa, f a * g a) = Œªa, indicator s f a * indicator s g a :=
by { funext, simp only [indicator], split_ifs, { refl }, rw mul_zero }

end mul_zero_class

section monoid_with_zero

variables [monoid_with_zero Œ≤]

lemma indicator_prod_one {s : set Œ±} {t : set Œ±'}
  {x : Œ±} {y : Œ±'} : (s.prod t).indicator (1 : _ ‚Üí Œ≤) (x, y) = s.indicator 1 x * t.indicator 1 y :=
by simp [indicator, ‚Üê ite_and]

end monoid_with_zero

section order
variables [has_zero Œ≤] [preorder Œ≤] {s t : set Œ±} {f g : Œ± ‚Üí Œ≤} {a : Œ±}

lemma indicator_nonneg' (h : a ‚àà s ‚Üí 0 ‚â§ f a) : 0 ‚â§ indicator s f a :=
by { rw indicator_apply, split_ifs with as, { exact h as }, refl }

lemma indicator_nonneg (h : ‚àÄ a ‚àà s, 0 ‚â§ f a) : ‚àÄ a, 0 ‚â§ indicator s f a :=
Œª a, indicator_nonneg' (h a)

lemma indicator_nonpos' (h : a ‚àà s ‚Üí f a ‚â§ 0) : indicator s f a ‚â§ 0 :=
by { rw indicator_apply, split_ifs with as, { exact h as }, refl }

lemma indicator_nonpos (h : ‚àÄ a ‚àà s, f a ‚â§ 0) : ‚àÄ a, indicator s f a ‚â§ 0 :=
Œª a, indicator_nonpos' (h a)

lemma indicator_le' (hfg : ‚àÄ a ‚àà s, f a ‚â§ g a) (hg : ‚àÄ a ‚àâ s, 0 ‚â§ g a) :
  indicator s f ‚â§ g :=
Œª a, if ha : a ‚àà s then by simpa [ha] using hfg a ha else by simpa [ha] using hg a ha

@[mono] lemma indicator_le_indicator (h : f a ‚â§ g a) : indicator s f a ‚â§ indicator s g a :=
indicator_rel_indicator (le_refl _) (Œª _, h)

lemma indicator_le_indicator_of_subset (h : s ‚äÜ t) (hf : ‚àÄa, 0 ‚â§ f a) (a : Œ±) :
  indicator s f a ‚â§ indicator t f a :=
begin
  simp only [indicator],
  split_ifs with h‚ÇÅ,
  { refl },
  { have := h h‚ÇÅ, contradiction },
  { exact hf a },
  { refl }
end

lemma indicator_le_self' (hf : ‚àÄ x ‚àâ s, 0 ‚â§ f x) : indicator s f ‚â§ f :=
indicator_le' (Œª _ _, le_refl _) hf

lemma indicator_le_self {Œ≤} [canonically_ordered_add_monoid Œ≤] (s : set Œ±) (f : Œ± ‚Üí Œ≤) :
  indicator s f ‚â§ f :=
indicator_le_self' $ Œª _ _, zero_le _

lemma indicator_le {Œ≤} [canonically_ordered_add_monoid Œ≤] {s : set Œ±}
  {f g : Œ± ‚Üí Œ≤} (hfg : ‚àÄ a ‚àà s, f a ‚â§ g a) :
  indicator s f ‚â§ g :=
indicator_le' hfg $ Œª _ _, zero_le _

lemma indicator_Union_apply {Œπ Œ≤} [complete_lattice Œ≤] [has_zero Œ≤] (h0 : (‚ä•:Œ≤) = 0)
  (s : Œπ ‚Üí set Œ±) (f : Œ± ‚Üí Œ≤) (x : Œ±) :
  indicator (‚ãÉ i, s i) f x = ‚®Ü i, indicator (s i) f x :=
begin
  by_cases hx : x ‚àà ‚ãÉ i, s i,
  { rw [indicator_of_mem hx],
    rw [mem_Union] at hx,
    refine le_antisymm _ (supr_le $ Œª i, indicator_le_self' (Œª x hx, h0 ‚ñ∏ bot_le) x),
    rcases hx with ‚ü®i, hi‚ü©,
    exact le_supr_of_le i (ge_of_eq $ indicator_of_mem hi _) },
  { rw [indicator_of_not_mem hx],
    simp only [mem_Union, not_exists] at hx,
    simp [hx, ‚Üê h0] }
end

end order

end set

lemma add_monoid_hom.map_indicator {M N : Type*} [add_monoid M] [add_monoid N] (f : M ‚Üí+ N)
  (s : set Œ±) (g : Œ± ‚Üí M) (x : Œ±) :
  f (s.indicator g x) = s.indicator (f ‚àò g) x :=
congr_fun (set.indicator_comp_of_zero f.map_zero).symm x
